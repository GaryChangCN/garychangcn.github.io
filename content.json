{"pages":[{"title":"about","text":"普通的程序员 email: garychangcn@hotmail.com","link":"/about/index.html"},{"title":"","text":"立方体 * { margin: 0; padding: 0; border: 0px; } .container { width: 100%; } /*.box:hover{ transform: rotateX(360deg) rotateY(360deg); }*/ @keyframes gogogo { 0% { transform: rotateX(0deg) rotateY(0deg); } 50% { transform: rotateX(180deg) rotateY(180deg); } 100% { transform: rotateX(360deg) rotateY(360deg); } } .box { transform-style: preserve-3d; /*perspective:400px;*/ position: relative; margin-left: 100px; margin-top: 100px; width: 200px; height: 200px; transition: transform 5s; animation: gogogo 2s linear infinite; } .box>div { width: 200px; height: 200px; position: absolute; line-height: 200px; text-align: center; opacity: 1; font-size: 40px; opacity: 0.9; } #front { background-color: red; transform: translateZ(100px); } #back { background-color: green; transform: translateZ(-100px) rotateY(180deg); } #top { background-color: lightblue; transform: rotateX(90deg) translateZ(100px); } #bottom { background-color: yellow; transform: rotateX(-90deg) translateZ(100px); } #left { background-color: pink; transform: rotateY(-90deg) translateZ(100px); } #right { background-color: orange; transform: rotateY(90deg) translateZ(100px); } front back top bottom left right","link":"/show/3d.html"},{"title":"","text":"class EventEmitter { constructor() { this._events = { } } emit(type) { var funL = this._events[type]; var args = Array.from(arguments).slice(1); funL.forEach(function(e) { e(...args); }) } addListener(type, func) { this._events = this._events || {}; if (!this._events[type]) { this._events[type] = []; } this._events[type].push(func); } removeListener(type,func){ this._events[type].splice(this._events[type].indexOf(func),1); } on(type, func){ this.addListener(type, func) } } module.exports={ emitter:EventEmitter }","link":"/show/EventEmitter.js"},{"title":"","text":"模拟alert confirm prompt body { bottom: 0; border: 0; padding: 0; font-family: \"微软雅黑\"; background-color: #eee; } .container { display: flex; flex-wrap: wrap; width: 300px; margin: 0px auto; align-items: center; justify-content: center; } .container>div { width: 100%; text-align: center; font-size: 20px; padding-bottom: 10px; padding-top: 10px; margin-bottom: 10px; border-top: 1px solid #333; margin-top: 15px; } button { background-color: #fff; border: 1px solid #999; height: 25px; margin: 0px 5px; } button:hover { background-color: #ddd; } .layout { position: fixed; width: 300px; min-height: 100px; background-color: #fff; border: 1px solid #000; left: 25%; left: calc(50% - 150px); top: 100px; box-shadow: 0px 3px 3px 3px #ddd; display: none; } .title { width: 100%; color: #fff; background-color: #000; height: 40px; line-height: 40px; text-align: center; font-size: 20px; } .close { position: absolute; top: 5px; right: 10px; color: #fff; font-size: 20px; transform: rotate(45deg); cursor: pointer; } .close:hover { color: #999; } .content { margin-top: 10px; padding: 20px; margin-bottom: 10px; } .control { background-color: #000; height: 40px; } .layout a:link { color: #fff; text-decoration: none; display: block; height: 40px; line-height: 40px; text-align: center; } .layout a:visited { color: #fff; text-decoration: none; } .layout a:hover { background-color: #666; } .confirm a { width: 50%; float: left; } .prompt>input{ margin: 15px 4%; width: 90%; height: 30px; } 提示 + 确定 提示 + 确定 取消 输入内容 + 确定 alert 原生alert 模拟alert confirm 原生confirm 模拟confirm prompt 原生prompt 模拟prompt function Layout() { this._confirm = null; this._prompt=null; } Layout.prototype.$watch = function(obj, prop, callback) { if (!obj.$property) { obj.$property = function(prop, value) { if (this[prop] != value) { this[prop] = value; return callback(this); } return this; }; } } Layout.prototype.close = function() { var layout = document.querySelectorAll(\".layout\"); Array.prototype.slice.apply(layout).forEach(function(e) { e.style.display = \"none\"; }); } Layout.prototype.alert = function(data) { var _this = this; document.querySelector(\".alert>.content\").innerText = data; document.querySelector(\".alert\").style.display = \"block\"; document.querySelector(\".alert>.close\").onclick = function() { _this.close(); } document.querySelector(\"#alertEnter\").onclick = function() { _this.close(); } } Layout.prototype.confirm = function(data) { var _this = this; document.querySelector(\".confirm>.content\").innerText = data; document.querySelector(\".confirm\").style.display = \"block\"; document.querySelector(\".confirm>.close\").onclick = function() { _this.close(); } document.querySelector(\"#confirmEnter\").onclick = function() { _this.close(); _this.$property('_confirm', true); } document.querySelector(\"#confirmCancel\").onclick = function() { _this.close(); _this.$property('_confirm', false); } } Layout.prototype.prompt=function(data){ var _this = this; document.querySelector(\".prompt>.title\").innerText = data; document.getElementById(\"userInput\").value=\"\"; document.querySelector(\".prompt\").style.display = \"block\"; document.querySelector(\".prompt>.close\").onclick = function() { _this.close(); } document.querySelector(\"#promptEnter\").onclick = function() { var value=document.getElementById(\"userInput\").value; _this.close(); _this.$property('_prompt', value); } } document.getElementById(\"oAlert\").onclick = function() { alert(\"这是原生alert\"); } document.getElementById(\"iAlert\").onclick = function() { var a = new Layout(); a.alert(\"这是模拟alert\"); } document.getElementById(\"oConfirm\").onclick = function() { var c = confirm(\"这是原生confirm\"); if (c) { alert(\"刚点击了确认\"); } else { alert(\"刚点击了取消\"); } } document.getElementById(\"iConfirm\").onclick = function() { var a = new Layout(); a.confirm(\"这是模拟confirm\"); a.$watch(a, '_confirm', function(obj) { if(a._confirm){ a.alert(\"刚点击了确认\"); }else{ a.alert(\"刚点击了取消\"); } }); } document.getElementById(\"oPrompt\").onclick=function(){ var p=prompt(\"这是原生prompt\",\"\") if(p){ alert(\"刚刚输入的是:\"+p); } } document.getElementById(\"iPrompt\").onclick=function(){ var a=new Layout(); a.prompt(\"这是模拟prompt\"); a.$watch(a, '_prompt', function(obj) { if(a._prompt){ a.alert(\"刚刚输入的是:\"+obj._prompt); }else{ a.alert(\"刚刚输入的是:\"+obj+_prompt); } }); }","link":"/show/alert.html"},{"title":"","text":"function go() { var date=new Date(); var hours = date.getHours(); hours = hours > 12 ? hours - 12 : hours; var minutes = date.getMinutes(); var seconds = date.getSeconds(); var milliSeconds=date.getMilliseconds(); var canvas = document.getElementById(\"canvas\"); var ctx = canvas.getContext(\"2d\"); ctx.clearRect(0,0,400,400); ctx.save(); ctx.beginPath(); ctx.lineWidth = \"5\"; ctx.translate(200, 200); ctx.rotate(Math.PI / 6 * (hours+minutes/60)); ctx.moveTo(0, 20); ctx.lineTo(0, -80); ctx.stroke(); ctx.restore(); ctx.save(); ctx.beginPath(); ctx.lineWidth = \"3\"; ctx.translate(200, 200); ctx.rotate(Math.PI / 30 * (minutes+seconds/60)); ctx.moveTo(0, 25); ctx.lineTo(0, -100); ctx.stroke(); ctx.restore(); ctx.save(); ctx.beginPath(); ctx.lineWidth = \"1\"; ctx.translate(200, 200); ctx.rotate(Math.PI / 30 * (seconds+milliSeconds/1000)); ctx.moveTo(0, 30); ctx.lineTo(0, -120); ctx.stroke(); ctx.restore(); ctx.save(); ctx.beginPath(); ctx.strokeStyle = \"#000\"; ctx.lineWidth = \"4\"; ctx.arc(200, 200, 150, 0, Math.PI * 2, false); ctx.stroke(); ctx.restore(); for (var i = 1; i","link":"/show/canvasclock.html"},{"title":"","text":"利用手机陀螺仪控制长方体运动 window.addEventListener(\"deviceorientation\",function(event){ //alpha 一般正北为0 var console=document.getElementById(\"console\"); console.innerHTML=\"Z轴：\"+event.alpha+\"X轴：\"+event.beta+\"Y轴：\"+event.gamma; });","link":"/show/gyrscope.html"},{"title":"","text":"科赫雪花 var canvas = document.getElementById(\"canvas\"); function koch(ctx, x1, y1, x2, y2, n, m) { ctx.clearRect(0,0,400,400); var x3 = (x2 - x1) / 3 + x1; var y3 = (y2 - y1) / 3 + y1; var x4 = (x2 - x1) / 3 * 2 + x1; var y4 = (y2 - y1) / 3 * 2 + y1; var x5 = x3 + ((x2 - x1) - (y2 - y1) * Math.sqrt(3)) / 6; var y5 = y3 + ((x2 - x1) * Math.sqrt(3) + (y2 - y1)) / 6; n++; if (n == m) { ctx.moveTo(x1, y1); ctx.lineTo(x3, y3); ctx.lineTo(x5, y5); ctx.lineTo(x4, y4); ctx.lineTo(x2, y2); ctx.stroke(); return false; } koch(ctx, x1, y1, x3, y3, n, m) koch(ctx, x3, y3, x5, y5, n, m) koch(ctx, x5, y5, x4, y4, n, m) koch(ctx, x4, y4, x2, y2, n, m) } function draw(deep) { var ctx = canvas.getContext(\"2d\"); ctx.strikeStyle=\"#000\"; ctx.beginPath(); var y=80+Math.cos(Math.PI/6)*200; koch(ctx,150,y,250,80,0,deep); koch(ctx,250,80,50,80,0,deep); koch(ctx,50,80,150,y,0,deep); } draw(1); var range=document.getElementById(\"range\"); range.onchange=function(){ var r=~~range.value; draw(r) } body { text-align: center; } #canvas { background-color: #fff; }","link":"/show/koch.html"},{"title":"","text":"使用media query 实现响应式布局 * { margin: 0; padding: 0; border: 0px; } body { background-color: #eee; font-family: \"微软雅黑\"; } @media screen and (min-width: 1000px) { .header { width: 100%; padding-top: 20px; background-color: #000; color: #fff; padding-bottom: 20px; } .title { font-size: 40px; margin-left: 40px; } .sub { margin-left: 40px; } nav { background-color: #444; height: 50px; line-height: 50px; color: #fff; padding-left: 40px; } .menu{ display: none; } nav>ul{ float: left; } nav>ul>li { list-style: none; float: left; width: 60px; text-align: center; } .search { width: 70px; margin-right: 140px; float: right; } .search>input { height: 30px; opacity: 0.5; border-radius: 5px; } .clear { clear: both; } .main { width: 600px; height: 200px; background-color: #999; margin-top: 40px; margin-left: 40px; float: left; } .minor { width: 300px; height: 200px; background-color: #999; float: right; margin-top: 40px; margin-right: 40px; } } @media screen and (max-width: 1000px) and (min-width: 560px) { .header { width: 100%; padding-top: 20px; background-color: #000; color: #fff; padding-bottom: 20px; } .title { font-size: 40px; margin-left: 40px; } .sub { margin-left: 40px; } nav { background-color: #444; height: 50px; line-height: 50px; color: #fff; padding-left: 40px; } .menu{ display: none; } nav>ul{ float: left; } nav>ul>li { list-style: none; float: left; width: 60px; text-align: center; } .search { width: 170px; float: right; height: 30px; padding-right: 40px; } .search>input { height: 30px; opacity: 0.5; width: 100%; border-radius: 5px; } .clear { clear: both; } .main { width: 90%; height: 200px; background-color: #999; margin-top: 40px; margin-left: auto; margin-right: auto; } .minor { width: 90%; height: 200px; background-color: #999; margin-top: 40px; margin-left: auto; margin-right: auto; } } @media screen and (max-width: 560px) and (min-width: 320px){ .header { width: 100%; padding-top: 20px; background-color: #000; color: #fff; padding-bottom: 20px; } .title { font-size: 40px; margin-left: 40px; } .sub { margin-left: 40px; } nav { background-color: #444; height: 50px; line-height: 50px; color: #fff; padding-left: 40px; position: relative; } .menu{ float: right; width: 38px; height: 38px; background-color: #333; margin-top: 5px; text-align: center; line-height: 40px; border-radius:2px; border:1px solid #000; margin-right: 20px; } .menu:hover+ul{ visibility: visible; height: 250px; } nav>ul { position: absolute; right: 0px; top: 50px; width: 100px; background-color: #444; visibility: hidden; height: 0px; transition: all 0.1s; } nav>ul>li { list-style: none; text-align: center; } .search { width: 70px; margin-right: 140px; } .search>input { height: 30px; opacity: 0.5; border-radius: 5px; } .clear { clear: both; } .main { width: 90%; height: 200px; background-color: #999; margin-top: 40px; margin-left: auto; margin-right: auto; } .minor { width: 90%; height: 200px; background-color: #999; margin-top: 40px; margin-left: auto; margin-right: auto; } } @media screen and (max-width: 320px) { .header { width: 100%; padding-top: 20px; background-color: #000; color: #fff; padding-bottom: 20px; } .title { font-size: 30px; margin-left: 20px; } .sub { font-size: 10px; margin-left: 20px; } nav { background-color: #444; height: 50px; line-height: 50px; color: #fff; padding-left: 40px; position: relative; } .menu{ float: right; width: 38px; height: 38px; background-color: #333; margin-top: 5px; text-align: center; line-height: 40px; border-radius:2px; border:1px solid #000; margin-right: 20px; } .menu:hover+ul{ visibility: visible; height: 250px; } nav>ul { position: absolute; right: 0px; top: 50px; width: 100px; background-color: #444; visibility: hidden; height: 0px; transition: all 0.1s; } nav>ul>li { list-style: none; text-align: center; } .search { width: 60%; float: left; margin-left: -8%; } .search>input { width: 100%; height: 30px; opacity: 0.5; border-radius: 5px; } .clear { clear: both; } .main { width: 90%; height: 200px; background-color: #999; margin-top: 10px; margin-left: auto; margin-right: auto; } .minor { width: 90%; height: 200px; background-color: #999; margin-top: 40px; margin-left: auto; margin-right: auto; } } Demo 这里是一个media query响应式布局demo M 导航 导航 导航 导航 导航 这里是文章主题内容。 此demo只使用了响应式布局，并未做字体适配。 我在上一篇文章说明了 使用rem来做页面适配 当屏幕宽度小于1000px时候，这个栏会放到底部","link":"/show/mediaquery.html"},{"title":"","text":"multi-room-chat","link":"/show/multiRoomChat.html"},{"title":"","text":"websocket 聊天室 * { padding: 0; margin: 0; border: 0; font-family: \"微软雅黑\"; list-style-type: none; } .container { width: 100vw; height: 100vh; position: relative; } ul { background-color: #eee; } #ul { height: 90vh; overflow: auto; width: 70vw; float: left; } #ul>li, #user>li { min-height: 40px; line-height: 40px; padding-left: 10px; } #ul>li:nth-child(odd) { background-color: #999; color: #eee; } #ul>li:first-child, #user>li:first-child { padding-left: 0; text-align: center; font-size: 20px; height: 50px; line-height: 50px; background-color: #666; color: #fff; } #user { float: left; width: 29vw; height: 90vh; border-left: 1vw solid #ddd; } form { float: left; height: 10vh; background-color: #666; width: 100vw; } #input { width: 48vw; height: 6vh; margin-top: 2vh; opacity: 0.5; padding-left: 2vw; margin-left: 15vw; } #submit { width: 20vw; height: 6vh; margin-top: 2vh; } #cover { position: fixed; width: inherit; height: inherit; background-color: #111; z-index: 99; } #username { width: 50vw; height: 6vh; margin-left: 25vw; margin-top: 40vh; display: inherit; } #ok { width: 20vw; display: inherit; height: 5vh; margin-left: 40vw; margin-top: 20vh; background-color: #fff; } 聊天室 var ul = document.getElementById(\"ul\"); ul.append = function(text) { var li = document.createElement(\"li\"); li.innerText = text; this.appendChild(li); } var msg = { \"name\": \"匿名\", \"msg\": \"未知消息\", \"log\": null } var socket = new WebSocket(\"ws://new.garychang.cn:7777\"); document.getElementById(\"ok\").onclick = function() { var value = document.getElementById(\"username\").value; var name = value ? value : \"匿名\"; document.getElementById(\"cover\").style.display = \"none\"; msg.name = name; msg.log = 0; socket.send(JSON.stringify(msg)); msg.log = 1; } window.addEventListener(\"beforeunload\", function(e) { msg.log = 2; socket.send(JSON.stringify(msg)); socket.close(); var confirmationMessage = '确定离开此页吗？'; (e || window.event).returnValue = confirmationMessage; return confirmationMessage; }); socket.onmessage = function(event) { var json = JSON.parse(event.data); ul.append(json.msg); var tmp = \"当前成员\"; json.list.forEach(function(e) { tmp += \"\" + e + \"\"; }); document.getElementById(\"user\").innerHTML = tmp; } window.onunload = function() { msg.log = 2; socket.send(JSON.stringify(msg)); socket.close(); } socket.onclose = function() { socket.close(); } document.getElementById(\"submit\").addEventListener(\"click\", function(event) { event.preventDefault(); msg.msg = document.getElementById(\"input\").value; socket.send(JSON.stringify(msg)); document.getElementById(\"input\").value=\"\"; });","link":"/show/websocket.html"},{"title":"","text":"var arr = [25, 18, 5, 96, 74, 52, 14, 14, 5]; function bubble(arr) { var len = arr.length; if (len = 0 && tmp < arr[j]) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = tmp; } return arr; } } function quick(arr) { var len=arr.length; if (len","link":"/show/sortAlgorithm.js"},{"title":"","text":"基于rem的适配方案 html { font-family: \"微软雅黑\"; } nav { height: 1rem; background-color: #eee; font-size: 0.5rem; line-height: 1rem; } .mit{ width: 9rem; margin: 0.5rem auto; border:2px solid #eee; padding: 0.2rem; } .pic { width: 0.7rem; height: 0.7em; background-color: red; float: left; } .name { font-size: 0.3rem; float: left; height: 0.7rem; line-height: 0.7rem; margin-left: 0.5rem; } .clean { clear: both; } .commit { font-size: 0.5rem; width: 8rem; margin: 0.3rem auto; border:2px solid #eee;; } 这里是导航栏 用户名 这里是评论,这里是评论这里是评论,这里是评论这里是评论,这里是评论这里是评论,这里是评论这里是评论,这里是评论 function setRem() { var width = document.documentElement.clientWidth ? document.documentElement.clientWidth : window.innerWidth; var rem = width / 10; document.querySelector(\"html\").style.fontSize = rem + \"px\"; } setRem(); window.addEventListener(\"resize\", function() { setRem(); });","link":"/show/rem.html"},{"title":"","text":"知乎日报vue2.0版本 Out of Service","link":"/show/zh-vue2.html"},{"title":"","text":"Unmei body { background-color: rgb(255, 251, 254); width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; } .content { margin-top: -20vh; text-align: center; } .title { font-size: 20px; } .clock { margin-top: 20px; font-size: 30px; font-weight: bold; } Since. Sep 06 2020 Z const startTime = new Date('2020/09/06 00:00:00').getTime() const parser = ms => { let d = 0 let h = 0 let m = 0 let s = 0 let ret = '' if (ms > 86400000) { d = Math.ceil(ms / 86400000) - 1 ms -= d * 86400000 ret += `${d} 天 ` } const now = new Date() now.setHours(0, 0, 0, 0) const current = new Date(now.getTime() + ms) ret += `${current.getHours()}小时 ${current.getMinutes()}分钟 ${current.getSeconds()}秒` return ret } const main = () => { setTimeout(() => { const time = parser(new Date().getTime() - startTime) document.getElementById('clock').innerText = time main() }, 1000) } main()","link":"/show/liebe/index.html"}],"posts":[{"title":"CSS3 3D立方体","text":"演示新窗口打开 思路首先需要给这个正方体的父容器设置 transform-style 属性为 preserve-3d 这样才能保证子元素是在一个三位空间内，再给父元素的 position 设置为 relative，然后给子元素正方体这6个面改变角度和位置使其在正确的位置并更改其 positon 为 absolute 相对于父元素定位。改变角度和位置都使用 transform 属性，之后在三维坐标系通过 rotate3d() 改变角度，通过 translate3d() 改变位置。就ok了。tips 微信目前无法展示此效果，请选择使用浏览器打开。 代码html12345678910&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt; &lt;div id=\"front\"&gt;front&lt;/div&gt; &lt;div id=\"back\"&gt;back&lt;/div&gt; &lt;div id=\"top\"&gt;top&lt;/div&gt; &lt;div id=\"bottom\"&gt;bottom&lt;/div&gt; &lt;div id=\"left\"&gt;left&lt;/div&gt; &lt;div id=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS *{ margin: 0; padding: 0; border:0px; } .container{ width: 400px; height: 200px; } /*.box:hover{ transform: rotateX(360deg) rotateY(360deg); }*/ @keyframes gogogo{ 0%{ transform: rotateX(0deg) rotateY(0deg); } 50%{ transform: rotateX(180deg) rotateY(180deg); } 100%{ transform: rotateX(360deg) rotateY(360deg); } } .box{ transform-style: preserve-3d; /* 这里perspective 为景深 */ /*perspective:400px;*/ position: relative; margin-left: 100px; margin-top: 300px; transition: transform 5s; animation:gogogo 2s linear infinite; } .box&gt;div{ width: 200px; height: 200px; position: absolute; line-height: 200px; text-align: center; opacity: 1; font-size: 40px; opacity: 0.9; } #front{ background-color: red; transform:translateZ(100px); } #back{ background-color: green; transform: translateZ(-100px) rotateY(180deg); } #top{ background-color: lightblue; transform: rotateX(90deg) translateZ(100px); } #bottom{ background-color: yellow; transform: rotateX(-90deg) translateZ(100px); } #left{ background-color: pink; transform:rotateY(-90deg) translateZ(100px); } #right{ background-color: orange; transform:rotateY(90deg) translateZ(100px); }","link":"/2016/08/12/3Dcube/"},{"title":"HTTP头Content-Type","text":"Content-Type application/x-www-form-urlencoded 将数据编码为name-&gt;value的键值对 multipart/formdata 将数据编码为一条信息 text/plain 数据以文本形式传输 text json xml html zip image/ipeg 传输图片 png gif video/mp4 视频 rmvb form 的enctype application/x-www-form-urlencoded 默认 miltipart/form-dataget使用application/x-www-form-urlencoded将name-&gt;value转换为url里面的查询字符串post将数据封装到http 的请求体中。","link":"/2016/01/01/Content-Type/"},{"title":"ES6-calss 以及理解原型链","text":"Class在ES6中，引入了Class，可以很方便的来定义类。例如 123456789class A { constructor(x,y){ this.x=x; this.y=y; } toString(){ return this.x+this.y; }} 事实上ES6的class只是一个语法糖。上述代码等同于： 1234567function AA(x,y){ this.x=x; this.y=y;}AA.prototype.toString=function(){ return this.x+this.y;} 所以 在实例化后 1234var a=new A();var aa=new AA();a.constructor===aa.prototype.constructor //true 继承在ES5中，继承一般使用链继承。即新构造函数的protype等于需要继承的的构造函数的实例化，即 12345function NEWAA(){}NEWAA.prototype=new AA(); 在ES6中使用class继承会显得清楚点。 1class NEWA extends A{}; 这时候使用extends方法让NEWA继承A的所有属性/方法，此时这两个类是一样的。 123456789class NEWA extends A{ constructor(x,y,a){ super(x,y); //调用父类的constructor(x,y) this.a=a; } toString(){ return this.a+super.toString(); //调用父类的toString()方法 }} 在这上述这个例子里 super可以理解成“超类”来代替父类实例，即生成一个this对象来指向父类。因为子类没有this对象，所以这个super方法是必须的。并且只有调用super之后才能在方法中使用this关键字。当子类不添加constructor方法时候，此时会默认添加，且会默认继承父类的所有arguments。 123constructor(...args){ super(...args);} 个人理解原型链简单来说即是 123456789101112131415function A(){};var a=new A();a.__proto__==A.prototype //truea.__proto__.constructor==A //truefunction B(){};B.prototype=new A();var b=new B();b.__proto__==B.prototype //trueb.__proto__.constructor==B //trueb.__proto__.__proto__==A.prototype //trueb.__proto__.__proto__.constructor==A //true class 的 getter 和setter同 ES5的一样（vue的响应式原理即使用这个） 12345678Object.defineProperty(obj,key,{ get:function(){ }, set:function(){ }}) ES6 class的getter和setter更加方便点。 1234567891011121314class A{ constructor(x){ this.x=x; } get a(){ return \"getter\"+this.x; } set a(value){ console.log(\"刚刚set：\"+value); }}var a=new A(\"tinytin\");a.a=\"newnewnew\" //刚刚set：newnewnewa.a //gettertinytin 这里get不能传参数！。 class 静态方法在方法前加上static即表示此方法不能被继承。 123456789class A{ static fun(){ return \"tinytin\" }}A.fun() //tinytinvar a=new A();a.fun() //error","link":"/2016/12/12/ES6-Class/"},{"title":"JavaScript Ajax封装 类似jQuery Ajax","text":"_Ajax简介简单封装的ajax库支持post和get方法 兼容IE7及以上浏览器和jQuery Ajax格式相似 源码源码 更新已更新jsonp跨域支持apioption123456789101112131415_Ajax({ \"url\":\"\", \"method\":\"\",//默认get \"async\":true,//默认为false \"data\":{ }, \"header\":{ }, \"cache\":true,//默认为false \"dataType\":\"\",//\"text\" \"json\" \"xml\" \"jsonp\"默认为text success:function(){ }, beforeSend:function(){ } }) libs:通过 &lt;script&gt;标签引入&lt;script src=&quot;lib/_Ajax.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 通过CDN获取http://ajax-10030624.file.myqcloud.com/_Ajax.js http://ajax-10030624.file.myqcloud.com/_Ajax.min.js example12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;_Ajax_Demo&lt;/title&gt; &lt;script src= \" lib/_Ajax.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; _Ajax({ \"url\":\"server.php\", \"method\":\"post\",//默认get \"async\":true,//默认为false \"data\":{ \"key\":\"value\", \"key2\":\"value2\" }, \"header\":{ \"h\":\"c\", \"h2\":\"c2\" }, \"cache\":true,//默认为false \"dataType\":\"json\",//\"text\" \"json\" \"xml\" 默认为text success:function(data){ }, beforeSend:function(){ } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2016/04/17/Ajaxpacking/"},{"title":"ES6-Map","text":"ES6引入Map的目的js 的对象本质上就是键值对集合也就是 Hash结构，但是只能用字符串作为键值，而 Map 就可以解决这个问题。 用法123456789101112var m= new Map();var o={ a:1};m.set(o,\"123\");m.get(o); // \"123\"m.has(o); // truem.delete(o); // truem.has(o); // false Map 可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组。 12345var map=new Map([[\"name\",\"mike\"],[\"age\",\"21\"]]);map.size // 2map.get(\"name\") // \"mike\" 实例属性及操作方法size 属性返回 Map 结构成员总数。 遍历方法 keys() 返回键名的遍历器。 values() 返回键值的遍历器。 entries() 返回所有成员的遍历器。 forEach() 遍历 Map 的所有成员。 与其他数据结构的转换Map 转为数组 使用 ES6 扩展运算符 （…） 1234var map=new Map([[\"name\",\"mike\"],[\"age\",\"21\"]]);[...map] // [[\"name\",\"mike\"],[\"age\",\"21\"]] 遍历器 这个不多赘述。 数组转为 Map将数组传入 Map 构造函数即可。 Map 转为对象如果 Map 的所有键都是字符串，则其可以转为对象。 Map 转 JSON当 Map 键名都是字符串时候，可以转为对象（json）。 WeakMap同 WeakSet 类似 WeakMap 的键名只能是对象。","link":"/2016/09/01/ES6-Map/"},{"title":"ES6 Generator 函数","text":"简介Genertor 函数是ES6提供的一种异步编程解决方法，从语法上，首先从语法上可以理解成一个成一个状态机，封装了多个内部状态。 执行 Generertor 函数会返回一个遍历器对象。也就是说， Generator 函数处理是状态机，还是一个遍历器对象生成函数。返回的遍历器对象，一次遍历Generator函数内部每一个状态。 形式1234567function* generator(){ yield 'hello'; yield 'world' return 'end';}var g= generator(); 上述代码定义了一个Generator 函数。内部有两个 yield 语句（'hello' 和 'world'）和一个return语句（用于结束执行）。 使用12345678console.log(g.next());//{ value: 'hello', done: false }console.log(g.next());//{ value: 'world', done: false }console.log(g.next());//{ value: 'end', done: true }console.log(g.next());//{ value: undefined, done: true } 在第四次两用时候，Generator 函数已经运行完毕，next方法返回的对象的value属性为undefined。 TipsES6 没有对丁 function 关键字和函数名之间的星号 * 下载那个位置。 yield 语句 遇到 yield 语句就暂停执行后面的操作，并将紧跟在 yield 后端表达式的值作为返回的对象的 value 属性值。 下一次调用 next 方法时在继续往下执行，直到遇到下一个 yield 为止。 如果没有遇到 yield 语句,就会一直运行到函数结束。直到遇到 return 语句，并将紧跟在 return 后端表达式的值作为返回的对象的 value 属性值。 如果该函数没有 return 语句，则返回的对象的 value 值为 undefined。 只有当调用 next 方法，yield 语句后面的表达式才会执行，因此等于为 JavaScript 提供了 懒惰求值 Lazy Evaluation 的语法功能 Generator 函数可以不用 yield 语句，此时就变成了一个单纯的暂缓执行函数。 1234567891011function * f(){ console.log(\"执行了\");}var g=f();setTimeout(function(){ g.next();},2000); 上面代码中，如果 f 是普通函数，则在为 generator 复制的时候就会执行。但是函数 f 是个 Generator 函数，于是就会在调用 next 方法时再回执行。 Tipsyield 语句不能用在普通函数中，会报错。 next 方法的参数yield 语句本身没有返回值，或者说总是返回 undefined 。next 方法可以带一个参数，该参数会被当作上一条 yield 语句的返回值。 123456789101112131415161718function * f(){ for(var i=0;true;i++){ var reset =yield i; if(reset){ i=-1; } }}var g=f();g.next();//{ value: 0, done: false }g.next();//{ value: 1, done: false }g.next(true);//{ value: 0, done: false } 上面的代码先定义一个可以无限运行的 Generator 函数 f ，如果 next 方法没有参数，每次运行到 yield 语句，变量 reset 的值总是 undefined 。当 next 方法带一个参数 true 时，当前的变量 reset 就被充值为这个参数（即为 true ），因而 i 会等于 -1 ，下一轮循环就从 -1 开始递增。 语法意义Generator 函数从暂停状态到回复运行，其上下文状态是不变的。通过 next 方法的参数就有办法在 Generator 函数开始运行后继续想函数体内部逐日值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整这个函数行为。 for…of 循环for…of 循环可以自动遍历 Generator 函数，此时不用调用 next 方法。 1234567891011121314function* generator(){ yield 1; yield 2; yield 3; yield 4; yield 5; return 6;}for(let v of generator()){ console.log(v);}//1 2 3 4 5 Generator.prototype.throw()throw 方法可以在函数体外抛出错误然后再 Generator 函数体内捕获。 Generator.prototype.return()Generator 函数返回的遍历器对象还有一个 return 方法，可以返回给定的值，并且中介 Generator 函数的遍历。 1234567891011121314function * gen(){ yield 1; yield 2; yield 3;}var g= gen()g.next();//{value:1,done:false}g.return(\"foo\");//{value:\"foo\",done:true};g.next();//{value:undefinded,done:true} 上述代码中，遍历器对象 g 调用 return 方法后，返回值的 value 属性就是 return 方法的参数 foo 。同时，Generator 函数便利种植，返回值的 done 属性变为 true ，以后再调用 next 方法， done 属性总是返回 true。 作为对象属性的 Generator 函数如果一个对象属性是 Generator 函数，那么可以简写成下面形式。 1234567891011121314let obj={ * gen(){ }};//等于let obj={ gen:function *(){ }}; Generator 函数的 thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，他继承了 Generator 函数的 Prototype 对象上的方法。意思是 在 generator 函数体内用 this 绑定属性是没用的。例如： 123456function *g(){ this.a=123;}var q=g();q.a//undefinded","link":"/2016/08/28/ES6-generator/"},{"title":"Set数据结构","text":"Set基本用法Set 是ES6 新的数据结构，类似于数组，但每一项都是唯一的没有重复项。 123456789var s=new Set();[2,3,5,5,1,2].map(function(e){ a.add(e);});console.log(s);//[2,3,5,1] Set 函数可以接受一个数组或者类似数组的对象作为参数，然后初始化。 向 Set 加入项时不会发生类型转换。 Set 实例的属性和方法 Set.prototype.constructor 返回 Set 本身。 Set.prototype.size 返回 Set 实例成员总数。 add() 添加一个值，返回 Set 结构本身。 delete(value) 删除一个值，返回 boolean 值。 clear() 清楚所有成员，无返回值。 遍历方法 keys() 返回一个键名的遍历器。 values() 返回一个键值的遍历器。 entries() 返回一个键值对遍历器。 forEach() 使用回调遍历没每一个成员。 WeakSetWeakSet 和 Set 相似都是不重复的集合，但有两个区别： WeakSet 成员只能是对象。 WeakSet 成员对象都是弱引用。所以 WeakSet 不可遍历。","link":"/2016/08/31/ES6-Set/"},{"title":"ES6 promise 对象","text":"含义 状态 promise 对象代表一个异步操作，有三种状态： Pending 进行中 Resolved 已完成 （又称Fulfilled） Rejected 失败 特点一旦状态改变就不会在改变。 目的解决回调写法的混乱以及一个统一标准。 以下文字至“用法”前来源于 原文连接 假设有一个数据库保存操作，一次请求需要在三个表中保存三次数据。那么我们的代码就跟上面的代码相似了。这时候假设在第二个db.save出了问题怎么办？基于这个考虑，我们又需要在每一层回调中使用类似try…catch这样的逻辑。这个就是万恶的来源，也是node刚开始广为诟病的一点。 12345678910db.save(data, function(data){ // do something... db.save(data1, function(data){ // do something... db.save(data2, function(data){ // do something... done(data3); // 返回数据 }) });}); 另外一个缺点就是，假设我们的三次保存之间并没有前后依赖关系，我们仍然需要等待前面的函数执行完毕, 才能执行下一步，而无法三个保存并行，之后返回一个三个保存过后需要的结果。（或者说实现起来需要技巧） 所以解决这个问题的库如 Q 等就出现了，直到 ES6 统一了标准。 用法12345678var promise = new Promise(function(resolve,reject){ //....async code if(/* 异步成功*/){ resolve(value); }else{ reject(err); }}) Promise 构造函数接受一个一名函数作为参数，这个函数有两个参数，分别为 reslove 和 reject。 resolve 作用是将promise对象由未完成变为成功。 reject 作用是将promise对象由未完成变成失败 Promise实例生成后可以使用 then 方法分别给 Resolve 和 Rejected 指定回调函数 12345promise.then(function(value){ //成功},function(err){ //失败}); 例子123456789funtion timeout(ms){ return new Promise(function(resolve,reject){ setTimeout(resolve,ms); });}timeout(1000).then(function(value){ console.log(value);}); 上述代码timeout函数返回一个 Promise 实例，表示1秒后的结果，当运行指定函数手， Promise 实例状态变为resolved 此时就会触发 then 方法绑定的回调函数。 promise的 then 方法依然会返回一个Promise实例（不等于原来那个），所以就能再用下一个 then 来处理。 Promise 数据流动引用内容同上 第一个then中的两个回调函数决定第一个then返回的是一个什么样的Promise对象。 假设第一个then的第一个回调没有返回一个Promise对象，那么第二个then的调用者还是原来的Promise对象，只不过其resolve的值变成了第一个then中第一个回调函数的返回值。 假设第一个then的第一个回调函数返回了一个Promise对象，那么第二个then的调用者变成了这个新的Promise对象，第二个then等待这个新的Promise对象resolve或者reject之后执行回调。 12345getJSON(\"/post.json\").then(function(json){ return json.post;}).then(function(post){ //......}); 上面代码使用then方法依次制订了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数传入第二个回调函数。采用链式then 可以指定一组按照次序调用的回调函数，这时候，前一个回调函数可能返回的还是一个Promise对象（即有异步操作），而后一个回调函数就会等待该Promise对象的状态发生变化时候在被调用。如下： 123456 return json.post;}).then(function pA(post){ //......},function pB(err){ //err.....}); 上面代码中，第一个then方法指定的回调函数返回的是另一个Promise 对象。这时候，第二个then方法指定的回调函数就会等待这个新的Promise对象状态发生变化。若变为 resolve 则会调用 pA 函数。若变为rejected 则会调用 pB 函数。 在这个“链条”上遇到的错误将一直向后 reject 。直到有处理为止。 ## Promise.prototype.catch() 此方法接受一个回调函数来处理错误。即是 .then(null,rehection) 的别名。 Promise.all()此方法将多个Promise 实例包装成一个新的实例。并非 Promise.prototype.all var p = Promise.all([p1,p2,p3]) 上述代码中，Promise.all 接受一个数组作为参数，数组每项都是一个 Promise 的实例，若不是就会调用 Promise.resolve方法将其转为 Promise 实例。 只有 p1，p2，p3 状态都变成 resolved ，p的状态才会变成 resolved ，此时 p1，p2，p3 的返回值会组成一个数组传递给 p 的回调函数。 只要 p1，p2，p3 状态变成 rejected ，p的状态就会变成 rejected 第一个被 rejected 的实例返回值会传递给 p 的回调函数。 Promise.race()Promise.race 方法同样是将多个 Promise实例包装成一个新的 Promise 实例。 var p = Promise.race([p1,p2,p3]); 上面代码中，只要p1，p2，p3 中任何一个实例状态改变，p 的状态就是跟着改变，最先改变的实例将会传递给 p 的回调函数。 Promise.resolve()将现有对象转换为 Promise 对象。 Promise.reject()此方法放回一个新的 Promise 实例，状态为 Rejected 。","link":"/2016/08/26/ES6-promise/"},{"title":"几种排序算法的javascript实现","text":"排序算法之前有用php总结过几个排序算法，也用js实现过，但是demo早就消失不见，刚好有题目是用js写一种排序算法，我就吧几种算法总结下。 冒泡排序冒泡排序简单来说就是把最大的冒泡出来，时间复杂度 O(n^2),最简单是 O(n)。 冒泡排序会进行两次循环，外层循环次数是数组长度减去1，内层循环是从数组第一位到上次处理后的最后一位，因为最大or最小值会冒泡上去，循环次数也是。 1234567891011121314151617function bubble(arr) { var len = arr.length; if (len &lt;= 1) { return arr; } else { for (var i = 0; i &lt; len - 1; i++) { for (var j = 0; j &lt; len - i - 2; j++) { if (arr[j] &lt; arr[j + 1]) { var tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } return arr; }} 插入排序这个是我最早理解的排序，简单说就像从第一张那扑克，之后每拿一张就从已经在手上的牌的第一张或最后一张，往后或往前找到他应该在的未知，然后再拿下一张牌。时间复杂度 O(n^2),最简单是 O(n)。 1234567891011121314151617function insert(arr) { var len = arr.length; if (len &lt;= 1) { return arr; } else { for (var i = 1; i &lt; len; i++) { var tmp = arr[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; tmp &lt; arr[j]) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = tmp; } return arr; }} 快速排序这个理解起来是最简单的了，例如他先找出数组中的中间点，然后从数组中删除这个中间点，然后比较这个数组每一项与这个中间点大小对比，小的话放进左边新数组，大的话放进右边新数组，之后在递归调用定义此方法的函数（左右都要调用），之后用concat()连接起来数组并返回，这个方法首先应该加上判断数组以及每个子总长度，当长度只有1时候就返回，刚好快速排序也是把数组划分到最后只有一项，时间复杂度最简单 O(log2n) 最复杂 O(n^2)。 1234567891011121314151617181920212223function quick(arr) { var len=arr.length; if (len &lt;= 1) { return arr; } else { var coordIndex = Math.floor(len / 2); var coord = arr[coordIndex]; arr.splice(coordIndex, 1); var left = []; var right = []; var len2 = arr.length; for (var i = 0; i &lt; len2; i++) { if (arr[i] &lt; coord) { left.push(arr[i]); } else { right.push(arr[i]); } } var leftArr=quick(left); var rightArr=quick(right); return leftArr.concat([coord],rightArr); }} 其他算法待填坑。 js排序算法 源码源码","link":"/2016/12/21/SortingAlgorithm/"},{"title":"js模拟alert,confirm,prompt Demo","text":"目的如果使用原生alert、confirm 等，若用户设置禁止弹窗会影响网页功能，所以使用模拟alert等更为合适。 思路新建个构造函数，在其上加上属性方法来实现 alert、confirm、prompt功能。 部分代码css部分css 部分不多陈述，主要就是把这几个弹出框设置成 position:fixed 就行了，其余样式自己解决。 html部分这里我对三个弹出框用了三个容器包裹，大部分样式相同。页面基础样式为了方便使用了 flex 布局，详细flex布局可以参照我之前的文章。 flex布局语法简介 123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"alert layout\"&gt; &lt;div class=\"title\"&gt;提示&lt;/div&gt; &lt;div class=\"close\"&gt;+&lt;/div&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;div class=\"control\"&gt; &lt;a href=\"#\" class=\"enter\" id=\"alertEnter\"&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"confirm layout\"&gt; &lt;div class=\"title\"&gt;提示&lt;/div&gt; &lt;div class=\"close\"&gt;+&lt;/div&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;div class=\"control\"&gt; &lt;a href=\"#\" class=\"enter\" id=\"confirmEnter\"&gt;确定&lt;/a&gt; &lt;a href=\"#\" class=\"cancel\" id=\"confirmCancel\"&gt;取消&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"prompt layout\"&gt; &lt;div class=\"title\"&gt;输入内容&lt;/div&gt; &lt;div class=\"close\"&gt;+&lt;/div&gt; &lt;input type=\"text\" id=\"userInput\"&gt; &lt;div class=\"control\"&gt; &lt;a href=\"#\" class=\"enter\" id=\"promptEnter\"&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div&gt;alert&lt;/div&gt; &lt;button id=\"oAlert\"&gt;原生alert&lt;/button&gt; &lt;button id=\"iAlert\"&gt;模拟alert&lt;/button&gt; &lt;div&gt;confirm&lt;/div&gt; &lt;button id=\"oConfirm\"&gt;原生confirm&lt;/button&gt; &lt;button id=\"iConfirm\"&gt;模拟confirm&lt;/button&gt; &lt;div&gt;prompt&lt;/div&gt; &lt;button id=\"oPrompt\"&gt;原生prompt&lt;/button&gt; &lt;button id=\"iPrompt\"&gt;模拟prompt&lt;/button&gt; &lt;/div&gt; javascript部分 首先创建构造函数 Layout 1234function Layout() { this._confirm = null; this._prompt=null;} 给其加上监听属性的方法。 1234567891011Layout.prototype.$watch = function(obj, prop, callback) { if (!obj.$property) { obj.$property = function(prop, value) { if (this[prop] != value) { this[prop] = value; return callback(this); } return this; }; }} 在其原型上写上以下三种方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Layout.prototype.alert = function(data) { var _this = this; document.querySelector(\".alert&gt;.content\").innerText = data; document.querySelector(\".alert\").style.display = \"block\"; document.querySelector(\".alert&gt;.close\").onclick = function() { _this.close(); } document.querySelector(\"#alertEnter\").onclick = function() { _this.close(); }}Layout.prototype.confirm = function(data) { var _this = this; document.querySelector(\".confirm&gt;.content\").innerText = data; document.querySelector(\".confirm\").style.display = \"block\"; document.querySelector(\".confirm&gt;.close\").onclick = function() { _this.close(); } document.querySelector(\"#confirmEnter\").onclick = function() { _this.$property('_confirm', true); _this.close(); } document.querySelector(\"#confirmCancel\").onclick = function() { _this.$property('_confirm', false); _this.close(); }}Layout.prototype.prompt=function(data){ var _this = this; document.querySelector(\".prompt&gt;.title\").innerText = data; document.getElementById(\"userInput\").value=\"\"; document.querySelector(\".prompt\").style.display = \"block\"; document.querySelector(\".prompt&gt;.close\").onclick = function() { _this.close(); } document.querySelector(\"#promptEnter\").onclick = function() { var value=document.getElementById(\"userInput\").value; _this.$property('_prompt', value); _this.close(); }}//关闭弹窗方法。Layout.prototype.close = function() { var layout = document.querySelectorAll(\".layout\"); Array.prototype.slice.apply(layout).forEach(function(e) { e.style.display = \"none\"; });} 基础操作DOM方法及Layout 方法使用方式 12345678910111213141516171819202122232425262728293031323334353637383940414243document.getElementById(\"oAlert\").onclick = function() { alert(\"这是原生alert\");}document.getElementById(\"iAlert\").onclick = function() { var a = new Layout(); a.alert(\"这是模拟alert\");}document.getElementById(\"oConfirm\").onclick = function() { var c = confirm(\"这是原生confirm\"); if (c) { alert(\"刚点击了确认\"); } else { alert(\"刚点击了取消\"); }}document.getElementById(\"iConfirm\").onclick = function() { var a = new Layout(); a.confirm(\"这是模拟confirm\"); a.$watch(a, '_confirm', function(obj) { if(a._confirm){ a.alert(\"刚点击了确认\"); }else{ a.alert(\"刚点击了取消\"); } });}document.getElementById(\"oPrompt\").onclick=function(){ var p=prompt(\"这是原生prompt\",\"\") if(p){ alert(\"刚刚输入的是:\"+p); }}document.getElementById(\"iPrompt\").onclick=function(){ var a=new Layout(); a.prompt(\"这是模拟prompt\"); a.$watch(a, '_prompt', function(obj) { if(a._prompt){ a.alert(\"刚刚输入的是:\"+obj._prompt); }else{ a.alert(\"刚刚输入的是:\"+obj+_prompt); } });} Demo新窗口打开","link":"/2016/08/22/alertpromptconfirm/"},{"title":"2016年阿里秋季校招前端题","text":"吐槽首先这个博文不是内容不是全部的前端题目，而只是我考的其中一道题，每个人的题目也不一样，写这个文章是自我安慰下昨天答错的题，尽管也没什么用了。 不过不得不说，阿里题目出的比京东强多了，但是编程题不能离开浏览器用本地编辑器也是很不爽的，但是我还是切出来用编辑器了。从今年秋季内推面试挂了到昨天笔试不理想，我想我的校招阿里之路也再见了。 题目题目是大概这样的：定义个查找方法和排序方法来查找数据，没有规定 .orderBy() 或者 where() 是不是可选的。 1234567891011121314151617var data = [ { userId: 8, title: 'title1' }, { userId: 11, title: 'other' }, { userId: 15, title: null }, { userId: 19, title: 'title2' }];var find = function(origin){ //your code are here...}//查找data中，符合条件的数据，并进行排序var result = find(data).where({\"title\": /\\d$/}).orderBy('userId', 'desc');console.log(result); // 返回值// [{ userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }]; 解答方法很简单，在 find 函数中定义个构造函数并返回其实例。给这个构造函数添加方法就行。没有用到原型链什么的，当时想多了 :-( 12345678910111213141516171819202122232425262728293031323334var find = function(data) { function A(data) { this.$data = []; var $this=this; this.where = function(where) { data.forEach(function(e) { for (var key in where) { if (where[key] instanceof RegExp) { if (where[key].test(e[key])) { $this.$data.push(e); } } else if (where[key] == e[key]) { $this.$data.push(e); } } }); return this; }; this.orderBy=function(id,order){ this.$data.sort(function(a,b){ if(order=\"desc\"){ return b[id]-a[id]; } }); return this.$data; } }; return new A(data);}var result = find(data).where({ \"title\": /\\d$/ }).orderBy('userId', 'desc');console.log(result);//[ { userId: 19, title: 'title2' },// { userId: 8, title: 'title1' } ]","link":"/2016/09/09/aliCampus/"},{"title":"用javascript生成回型矩阵 蛇形矩阵","text":"回型/蛇形矩阵形式12341 2 38 9 47 6 5 上述这种形式即为蛇形矩阵。 解决思路给定一个数字 n（为最终值例如上述中 9）首先先判断有几行几列，这里只要求出n 的中间公约数。例如 9 的中间公约数为 3 ，所以为三行三列。若 n 为 20 则中间公约数分别是4，5.所以为四行五列。 之后在根据行列中比较小的那个来判断有几层“回字型”。例如n=9 时候有三层，n=20 时候也是三层。然后就可以写个递归来把这些数字放进一个二维数组中的合适位置上。 javascript源码在浏览器控制台即可调用 Annular 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Annular(n) { n = parseInt(n); var divisor = []; for (var i = 1; i &lt;= n; i++) { if (n % i == 0) { divisor.push(i); } } var len = divisor.length; if (len % 2 == 0) { var mid = len / 2; var row = divisor[mid - 1]; var col = divisor[mid]; } else { var row = divisor[Math.floor(len / 2)]; var col = row; } //console.log(\"行：\" + row + \" 列：\" + col); var arr = new Array(row) for (var j = 0; j &lt; arr.length; j++) { arr[j] = new Array(col) } var quan = Math.ceil(row / 2); var begin = 1; var q = 0; while (q &lt; quan) { var top = col - q * 2; for (var i = 0; i &lt; top; i++) { arr[q][i + q] = begin + i; } var right = row - q * 2; for (var i = 0; i &lt; right; i++) { arr[i + q][col - 1 - q] = begin + top - 1 + i; } var bottom = col - q * 2; for (var i = 0; i &lt; bottom; i++) { arr[row - 1 - q][bottom - i - 1 + q] = begin + top - 1 + right - 1 + i; } var left = row - q * 2 - 1; for (var i = 0; i &lt; left; i++) { arr[row - 1 - q - i][q] = begin + top - 1 + right - 1 + bottom - 1 + i; } var stop = begin + top + right + bottom + left - 4; begin = stop + 1; q++; } console.log(arr);} 例子12345678910111213141516171819Annular(25);//输出[ [ 1, 2, 3, 4, 5 ], [ 16, 17, 18, 19, 6 ], [ 15, 24, 25, 20, 7 ], [ 14, 23, 22, 21, 8 ], [ 13, 12, 11, 10, 9 ] ]Annular(25);//输出[ [ 1, 2, 3, 4, 5 ], [ 14, 15, 16, 17, 6 ], [ 13, 20, 19, 18, 7 ], [ 12, 11, 10, 9, 8 ] ]","link":"/2016/09/05/annular/"},{"title":"音频编码与容器关系","text":"关系图 MEPG-1 or MPEG-2 Audio Layer III有损压缩mepg 组织即 MP3 编码格式 扩展名 .mp3 Layer 3:224 - 320 kbit/s优秀，192 - 224 kbit/s很好，128 - 192 kbit/s好 mime audio/mepg audio/MPA audio/mpa-robust AAC有损压缩Fraunhofer IIS、杜比实验室、AT&amp;T、Sony、Nokia 扩展名 .aac 使用 MPEG-2 Audio Transport Stream 作为容器 .mp4/.3gp 使用了MPEG-4 Part 14 的简化版即3GPP Media Release 6 Basic 进行封装的AAC编码 .m4a 为了区别纯音频MP4文件和包含视频的MP4文件而由苹果使用的扩展名mime audio/aac, audio/aacp, audio/3gpp, audio/3gpp2, audio/mp4, audio/MP4A-LATM, audio/mpeg4-generic Vorbis有损压缩Xiph.Org基金会 扩展名 .ogg/.oga ogg只留给Vorbis格式来使用 也就是将Vorbis编码的音效包含在Ogg的容器中所成的格式, 只包含音效所用的.oga .mka Matroska(一种多媒体封装格式) .webm 由 Google 资助的项目, 支持 Vorbis、Opus音频编解码器，使用的封装格式则以 Matroska 格式为基础。mime audio/ogg, audio/vorbis, audio/vorbis-config Speex有损压缩Xiph.Org基金会已被废弃，建议使用 Opus 取代 Opus有损压缩Xiph.Org基金会 扩展名 .opus .ogg .webm .mkamimeaudio/ogg, audio/opus WAV不压缩微软、IBM 扩展名 .wavmimeaudio/wav audio/wave audio/x-wav AIFF不压缩苹果 扩展名 .aiff .aif aifcmimeaudio/x-aiff audio/aif FLAC无损压缩Xiph.Org基金会 扩展名 .flac .oggmimeaudio/x-flac, audio/ogg ALAC无损压缩Apple 扩展名 .m4a Monkey’s Audio无损压缩Matthew T. Ashland 扩展名 .ape","link":"/2018/02/03/audioencode/"},{"title":"angularjs 全局非阻塞消息通知","text":"目的因为我的一个angularjs fruit-angular 项目要用的关系，而我又不想用bootstrap或者什么消息通知库之类，所以自己写了个。 预览 思路新建个service 数据依附在$rootScope 上，之后在新建个指令 ，再把指令放在根html上。 代码123456789101112131415161718192021222324252627//app.js var app = angular.module('xxx', []);//serviceapp.factory('alertService', ['$rootScope', '$timeout', function($rootScope, $timeout) { var alertService = {}; $rootScope.alerts = []; alertService.closeAlert = function(alert) { alertService.closeAlertIdx($rootScope.alerts.indexOf(alert)); }; alertService.closeAlertIdx = function(index) { $rootScope.alerts.splice(index, 1); }; alertService.add = function(msg) { var tmp = { msg: msg, close: function() { alertService.closeAlert(this) } } $rootScope.alerts.push(tmp); $timeout(function() { $rootScope.alerts.shift(); }, 2500); }; return alertService;}]); 上述代码中，我给 $rootScope 添加了alerts属性，是一个数组，用来存储消息。之后给 alertService 服务添加了几个方法，分别用来添加消息，关闭/删除消息，以及设定定时器，即2.5秒后自动删除第一条消息。 12345678910111213//directiveapp.directive('myAlert', function() { return { restrice: 'ECMA', replace: true, scope: { myData: '=' }, templateUrl: 'template/alert.html' };}); 上述代码，我添加个指令，名字为myAlert. 1234567891011121314//template/alert.html&lt;div style=\"position: fixed;z-index: 70;top: 0.2rem;\"&gt; &lt;div ng-repeat=\"item in myData\" style=\"position: relative;width:6rem;min-height: 1rem;color: #0b9058;;border-radius:0 0.2rem 0.2rem 0;margin-bottom: 0.3rem;padding:0.2rem 0.6rem 0.2rem 0.2rem;background-color:rgba(252,253,253,0.7);\"&gt; &lt;p style=\"font-size: 0.4rem;\"&gt;{{item.msg}}&lt;/p&gt; &lt;span ng-click=\"item.close()\" style=\"position: absolute;right: -0.1rem;top:-0.1rem;color:#fcfdfd;background-color: #0b9058;border-radius: 50%;width: 0.5rem;height: 0.5rem;text-align: center;line-height: 0.5rem;cursor: pointer;font-size: 0.3rem;\"&gt;×&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;//index.html&lt;my-alert my-data=\"alerts\"&gt;&lt;/my-alert&gt; 上述代码，我添加了之前指令对应的模版文件，这里用了行内样式。之后在index.html里面引入指令。","link":"/2016/09/22/angular-message/"},{"title":"音频可视化与音频处理","text":"前言来自于 Web Audio Api 音频可视化话不多说直接上代码。最终显示的图是频谱图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Index extends React.Component&lt;any, any&gt; { ref: HTMLAudioElement canvas: HTMLCanvasElement ctx: CanvasRenderingContext2D uint8Arr: Uint8Array start () { this.ref.play() const audioCtx = new AudioContext() const audio = document.getElementById('audio') as HTMLMediaElement const src = audioCtx.createMediaElementSource(audio) const gainNode = audioCtx.createGain() src.connect(gainNode) const analyserNode = audioCtx.createAnalyser() gainNode.connect(analyserNode) const processingNode = audioCtx.createScriptProcessor(1024) this.uint8Arr = new Uint8Array(analyserNode.frequencyBinCount) const canvas = document.getElementById('canvas') as HTMLCanvasElement const ctx = canvas.getContext('2d') this.canvas = canvas this.ctx = ctx ctx.fillStyle = 'red' processingNode.onaudioprocess = e =&gt; { analyserNode.getByteFrequencyData(this.uint8Arr) // 以下代码用于 给音频添加白噪音 // const inputBuf = e.inputBuffer // const outputBuf = e.outputBuffer // for (let outChannel = 0; outChannel &lt; outputBuf.numberOfChannels; outChannel ++) { // const inputDate = inputBuf.getChannelData(outChannel) // const outputData = outputBuf.getChannelData(outChannel) // for (let i = 0; i &lt; inputBuf.length; i ++) { // outputData[i] = inputDate[i] // outputData[i] += ((Math.random() * 2) - 1) * 0.2 // } // } } processingNode.connect(gainNode) gainNode.connect(audioCtx.destination) } draw () { const inner = () =&gt; { const {ctx, canvas, uint8Arr} = this ctx.clearRect(0, 0, canvas.width, canvas.height) uint8Arr.forEach((item, i) =&gt; { const height = item const x = 2.5 * i ctx.fillRect(x, canvas.height - height, 2, height) }) requestAnimationFrame(inner) } return inner() } handleStart () { this.start() this.draw() } render () { return ( &lt;div className=\"main\"&gt; &lt;div&gt; &lt;button onClick={() =&gt; this.handleStart()}&gt;start&lt;/button&gt; &lt;/div&gt; &lt;canvas id=\"canvas\" width=\"2560\" height=\"300\"&gt;&lt;/canvas&gt; &lt;audio ref={ref =&gt; this.ref = ref} src=\"http://127.0.0.1:7070/music.mp3\" id=\"audio\" crossOrigin=\"anonymous\" &gt;&lt;/audio&gt; &lt;/div&gt; ) }}","link":"/2018/02/03/audiovisible/"},{"title":"使用 audioContext 演奏音乐","text":"前言好久没有更新博客，最近研究了web音频。对音频编码格式和音频容器格式略有了解。同时也关注了 Web Audio Api，发现了一些好玩的东西。例如： 音频可视化 音频处理 创建和弦 等等 使用 audioContext 演奏音乐代码直接当在 codePen 了 键盘 1234567 就可以发声了","link":"/2018/02/03/audiocontext/"},{"title":"字符串匹配模式算法","text":"目录 BF算法 KMP算法 BF算法BF算法，又称为蛮力算法，思路是从主串第一个字符开始和模式串中第一个字符开始比较，若相等则继续比较后续自负，否则从主串中的第二个字符开始与模式串中第一个字符比较。按照这个方式，继续下去。如果模式串和主串中某一段连续子串相等，则匹配成功，返回模式串第一个字符在主串中的位置，否则返回 -1 。 源码12345678910111213141516171819202122232425262728String.prototype.$indexOf = function(child) { var i = 0; var j = 0; var sLen = this.length; var tLen = child.length; while (i &lt; sLen &amp;&amp; j &lt; tLen) { if (this[i] == child[j]) { i++; j++; } else { j = 0; i = i + 1 - j; } } if (j &gt;= tLen) { return i - tLen; } else { return -1; }};//testvar s = \"ababcacabcabbab\";var t = \"abcab\";var t2 = \"abcadw\";console.log(s.$indexOf(t))//7console.log(s.$indexOf(t2))//-1 时间复杂度主串长度 n , 模式串长度 m 。 最好情况下是 O(m) 此时主串前 m 个字符刚好是模式串。最欢情况是 O(m*n) 。 KMP算法BF算法算法之所以被称为蛮力算法是因为每次主串指针都会回溯，KMP算法则弥补这点，所以其时间复杂度为 O(m+n) 。 原理这个算法我确实看了很久，从看书到搜索资料也没有对我来说讲的能让我听懂的，但是最后我还是理解了，这里我不会说的很详细，毕竟这个博文也是给自己看的。 部分匹配数组 部分匹配数组是KMP算法最重要的一环。 例如 123\"ABCDABD\"//部分匹配数组[0,0,0,0,1,2,0] 其计算方式是前缀数组与后缀数组的共有元素里长度最长的共有元素的长度。前缀即出最后一个元素以外，后缀即除了第一个元素以外。 元素 前缀数组 后缀数组 结果 A NULL NULL 0 AB [A] [B] 0 ABC [A,AB] [BC,C] 0 ABCD [A,AB,ABC] [BCD,CD,D] 0 ABCDA [A,AB,ABC,ABCD] [BCDA,CDA,DA,A] 1 ABCDAB [A,AB,ABC,ABCD,ABCDA] [BCDAB,CDAB,DAB,AB,B] 2 ABCDABD [ABCDAB,ABCDA,ABCD,ABC,AB,A] [BCDABD,CDABD,DABD,ABD,BD,D] 0 之后和BF算法相似，知识在移动模式字符串时候其指针移动不同。 源码&amp;&amp;注释var s = \"abcdgaryabcdabdchang\"; var t = \"abcdabd\"; String.prototype.$indexOf = function(child) { var next = []; //定义部分匹配数组 //求匹配数组算法 var childLength = child.length; var i; for (i = 1; i &lt;= childLength; i++) { var now = child.slice(0, i); if (i == 1) { next.push(0); } else { var prefix, suffix; var dis = function(str, isSuf) { var len = str.length; var i, tmp = []; if (isSuf) { for (i = 1; i &lt;= len; i++) { tmp.push(str.slice(-i)); } } else { for (i = 1; i &lt;= len; i++) { tmp.push(str.slice(0, i)); } } return tmp; } prefix = dis(now.slice(0, -1), false); suffix = dis(now.slice(1), true); var equal = 0; prefix.forEach(function(e, index) { if (e === suffix[index]) { equal = e.length; } }); next.push(equal); } } //求匹配数组算法结束 return (function(s) { var i = 0; var j = 0; var sLen = s.length; var tLen = child.length; while (i &lt; sLen &amp;&amp; j &lt; tLen) { if (s[i] == child[j] || j == -1) { i++; j++; } else { j = next[j] - 1; //根据匹配数组更改其指针 } } if (j &gt;= tLen) { return i - tLen; } else { return -1; } }(this)); }; console.log(\"123456\".$indexOf(\"69\")); //-1 console.log(s.$indexOf(t)); //8 时间复杂度O(m+n) 参考资料 图解KMP算法 《数据结构与经典算法》————清华大学出版社","link":"/2017/02/04/bf-kmp-algorithm/"},{"title":"npm body-parser 中文api","text":"#body-parser node.js body parsing 中间件安装1$ npm install body-parser API1var bodyPaeser =require('body-parser') 可以通过body-parser 对象创建中间件，当接收到客户端请求时所有的中间件都会给req.body 添加属性，请求体为空，则解析为空{} （或者出现错误）。bodyParser.json(options)中间件只会解析 json ，允许请求提任意Unicode编码支持 gzip 和 deflate 编码。options一个对象，有以下属性inflate默认为false，true-&gt;压缩的请求体会被解压，false-&gt;压缩的请求提不被解压。limit控制请求体最大大小，默认为100kb，当为数字时会转换为bytes，当为字符串时，value值会通过 bytes库 转换为字节大小。reviver此选项会通过JSON.parse直接传给其第二个参数。strict默认为true，当为true时只接受数组和对象，当为false时会接受任何JSON.parse 能接受的。typetype 选项用来决定中间件要解析媒体类型。选项可以是一个函数或者是字符串。当为字符串时，可以直接通过type-is 库直接传递给选项，字符串也可以为一个扩展名（例如json）、mime 类型（application/json、/ 、*/json）。当为函数时：默认为application/json。verifyverify选项，若缺失则为一个函数function（req,res,buf,encoding）,buf为一个Buffer。bodyParse.raw(option)将请求体内容作为Buffer来处理，并返回。支持gzip deflate 压缩。inflatelimittypeverifybodyParser.text(option)将请求提内容作为字符串来处理，并返回。支持gzip deflate 压缩。defaultCharset若请求头未设置Content-Type则默认为utf8inflatetypeverifybodyParser.urlencoded(option)中间件只解析urlencoded 请求体，并返回，只支持UTF-8编号文本，支持gzip deflate 压缩。extendture-&gt;使用queryString库（默认） false-&gt;使用qs库。limitparameterlimit指定parameters最长长度，默认1000typeverify","link":"/2016/05/29/body-parser/"},{"title":"js括号匹配检验","text":"表达式中括号都是成对出现，否则则报错，现在用js实现这个表达式括号匹配验证。 思路使用栈来解决，当检索到左边括号时候推入到栈顶，当检测到右边括号时候则与取出栈顶元素并进行比较，最后计算栈的长度是否为空即可。 源码123456789101112131415161718192021222324252627282930313233343536String.prototype.bracket = function() { var stack = []; var sArr = this.split(\"\"); sArr.forEach(function(e) { if (/(\\(|\\[|\\{)/.test(e)) { stack.push(e); } else { switch (e) { case \")\": var top = stack.pop(); if (top !== \"(\") { return false; } break; case \"]\": var top = stack.pop(); if (top !== \"[\") { return false; } break; case \"}\": var top = stack.pop(); if (top !== \"{\") { return false; } break; default: } } }); return stack.length === 0;}console.log(\"{eqwe(qw}()\".bracket()); //falseconsole.log(\"{gary(chang)[cn]}(c)\".bracket()); //true","link":"/2017/02/02/bracket/"},{"title":"使用canvas制作的的钟","text":"效果新窗口打开 思路 绘制圆形表盘 绘制标线 绘制小时标线 绘制分钟、秒标线 绘制指针 时针 分针 秒针 绘制指针交汇点白色点 动起来 源码下载下载 源码以及注释讲解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 function go() { var date=new Date();//每个更新重新获取时间 var hours = date.getHours(); hours = hours &gt; 12 ? hours - 12 : hours; //24小时制转为12小时制 var minutes = date.getMinutes(); var seconds = date.getSeconds(); var milliSeconds=date.getMilliseconds();//这里获得毫秒是为了让秒针“顺滑”旋转 var canvas = document.getElementById(\"canvas\"); var ctx = canvas.getContext(\"2d\"); ctx.clearRect(0,0,400,400); //清空画布 ctx.save(); //这里绘制时针 ctx.beginPath(); ctx.lineWidth = \"5\"; ctx.translate(200, 200); //移动中间点 ctx.rotate(Math.PI / 6 * (hours+minutes/60)); //因为根据分钟走的百分比以及当前小时判断时针应该在的角度。以下同理 ctx.moveTo(0, 20); //设定20目的是让时针有个短边，以下同理 ctx.lineTo(0, -80); ctx.stroke(); ctx.restore(); ctx.save(); //绘制分针 ctx.beginPath(); ctx.lineWidth = \"3\"; ctx.translate(200, 200); ctx.rotate(Math.PI / 30 * (minutes+seconds/60)); ctx.moveTo(0, 25); ctx.lineTo(0, -100); ctx.stroke(); ctx.restore(); ctx.save(); //绘制秒针 ctx.beginPath(); ctx.lineWidth = \"1\"; ctx.translate(200, 200); ctx.rotate(Math.PI / 30 * (seconds+milliSeconds/1000)); //这里为了表现出平滑旋转效果采用毫秒的百分比计算角度，如果喜欢秒针“跳跃效果”可以把 milliSeconds/1000 删除 ctx.moveTo(0, 30); ctx.lineTo(0, -120); ctx.stroke(); ctx.restore(); //绘制表盘 ctx.save(); ctx.beginPath(); ctx.strokeStyle = \"#000\"; ctx.lineWidth = \"4\"; ctx.arc(200, 200, 150, 0, Math.PI * 2, false); ctx.stroke(); ctx.restore(); //这里是绘制小时标线 for (var i = 1; i &lt;= 12; i++) { ctx.save(); ctx.beginPath(); ctx.lineWidth = \"3\"; ctx.translate(200, 200); ctx.rotate(Math.PI / 6 * i); ctx.moveTo(0, -135); ctx.lineTo(0, -150); ctx.stroke(); ctx.restore(); } //这里绘制分和秒的标线 for (var j = 1; j &lt;= 60; j++) { ctx.save(); ctx.beginPath(); ctx.lineWidth = \"1\"; ctx.translate(200, 200); ctx.rotate(Math.PI / 30 * j); ctx.moveTo(0, -140); ctx.lineTo(0, -150); ctx.stroke(); ctx.restore(); } //绘制指针重合的白点 ctx.save(); ctx.arc(200, 200, 1, 0, Math.PI * 2, false); ctx.fillStyle = \"#fff\"; ctx.fill(); ctx.restore(); //递归调用requestAnimationFrame requestAnimationFrame(go); } //使用requestAnimationFrame做动画效果 requestAnimationFrame(go);&lt;/html&gt;","link":"/2017/01/08/canvasclock/"},{"title":"两个template","text":"前言为了日常及工作使用，我写了两个构建工具模板 react-webpack-typescript-template和react-redux-template 使用redux1234git clone git@github.com:GaryChangCN/react-redux-template.gityarn installyarn run dev //开发环境yarn run build //生产环境 开发环境不压缩代码，开启react的调试模式，只把.jsx编辑成ES5。 生产环节压缩代码，开启react生产环境模式，编译成es5。 使用typescript1234git clone git@github.com:GaryChangCN/react-webpack-typescript-template.gityarn installyarn run dev //开发环境yarn run build //生产环境 开发环境不压缩代码，开启react的调试模式，只把.tsx编辑成ES6。 生产环节压缩代码，开启react生产环境模式，编译成es5。 关于bebel昨天我阅读了babel以及周边库的用处，感觉前端现阶段已经很难离开babel了，有机会会记录下来。","link":"/2017/05/14/cli-react/"},{"title":"CSS中百分比基准","text":"width相对于父元素的宽度，注意这里以及以下父元素是指css中其父元素。而不是一般的DOM结构中父元素。 height一般是相对于父元素的高度，但是当父元素高度没有指定时候其值会变成 auto。 margin相对于父元素宽度。 padding同上 border-radius这个稍微复杂，根据 MDN 解释。水平半轴相对于合模型（自身）的宽度，垂直半轴相对于自身高度。 background-position根据其所在的元素的尺寸来的，默认是0% 0%。由此文得知： background-position的百分比值，取的参照是一个减法计算值，由放置背景图的区域尺寸，减去背景图的尺寸得到，可以为负值。对照上面的示例，思考一下，应该可以感受到，以这个减法计算值为参照的话，正好可以符合我们感官上对背景图位置的理解。 font-size基于父元素的字体大小。 line-height基于自身的字体大小，这里line-height原理是line-height值减去字体大小值后平分放置在字体上下。 vertical-align基于自身的 line-height 。 bottom top基于其父元素的高度。 left right基于其父元素宽度。 参考资料MDN 详述css中的百分比值","link":"/2016/12/16/css-percentage/"},{"title":"decorator 修饰符","text":"修饰器 decorator 是ES7的一个提案，可以用babel转来使用。 修饰类 1234567//定义个修饰符function changeClass(target){ target.property=\"new property\"}@changeClassclass testClass{}console.log(testClass.property) //new property 上述代码可以看出，修饰器接受的第一个参数是“目标”，当这个目标是类时可以更改其静态属性和原型属性。 修饰器第二个参数是要修饰的属性名，第三个参数是其“描述对象”descriptor，这个描述对象即Object.defineProperty({},key,descriptor)中的描述对象，可以更改是否可枚举、可写等","link":"/2017/06/29/decorator/"},{"title":"使用fetch来取代Ajax","text":"为什么要使用Fetch传统ajax or XMLHttpRequest()往往非常复杂的，而且并不好记忆。例如手写一个ajax ： 123456789101112131415var xhr = new XMLHttpRequest();//不考虑浏览器兼容性xhr.open(\"get\",\"garychang.cn\",true);xhr.onreadystatechange=function(){ if(xhr.readyState==4){ if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304){ console.log(xhr.responseText); } }}//或者 onload方法稍稍简单点。xhr.onerror=function(err){ //error......}xhr.send(null); 如果是 post 方式还要加上头。 1xhr.setRequestHeader('Content-Type','x-www-form-urlencoded'); 当然你可以自己封装成函数来使用（例如我之前封装的_Ajax）或者 jQuery的$.ajax。 但是使用 fetch 就简洁的多。 1234567fetch(\"garychang.cn\").then(function(response) { return response.json();}).then(function(data) { console.log(data);}).catch(function(e) { console.log(e);}); 使用 箭头函数 后会更加简洁： 123fetch(\"garychang.cn\").then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log(e)) 什么是 Fetch根据 MDN 描述： Fetch 提供了对 Request 和 Response （以及其他与网络请求有关的）对象通用的定义。它之后能够被使用到很多场景中：service workers、Cache API、其他处理请求和响应的方式，甚至任何需要生成自己的响应的方式。 兼容性 使用fetch 使用了ES6 Promise 来实现。其实不懂Promise也可以看懂。 如最顶部 fetch 例子，使用fetch进行网络请求非常简单的。相比较于ajax，fetch可以提供更多的功能： 123456789101112var opt={ headers: { 'Cache-Control': 'no-cache', 'Accept':'application/json' }, method:'GET', body: 'a=1&amp;b=2' //当类型为post时候 body可以用 FormData()}fetch(\"garychang.cn\", opt).then(function(response){ // do something...}) 上述代码中,opt对象可以指定请求头，请求类型作为fetch方法的第二个函数。 引入接口 Headers 123var header = new Headers();header.append(\"Content-Type\", \"text/plain\"header.append(\"Content-Length\", content.length.toString()); Requestrequest是http请求对象（类似于Node.js 的 httpIncomingMessage 对象） 123456789var req=new Request('garychang.cn',{ headers: { 'Cache-Control': 'no-cache', 'Accept':'application/json' }, method:'GET', body:'a=1&amp;b=2', mod:cors //cors跨域相关}); Responsehttp响应对象，存在于fetch的回调。 response对象对于返回值（response）fetch 也有更多可玩性。 response.status 显示HTTP状态码。 response.ststusText HTTP 状态码说明。 response.ok 说明是否正确返回 body无论是请求还是相迎都有 body fecth也提供了方法来操作body。 body类型 ArrayBuffer ArrayBufferView （arraybuffer视图） Blob/File （图片等） String （字符串） URLSearchParams （url查询字符串） FormData （表单数据） 对应处理方法 arrayBuffer() 同上 blob() json() text() formData()","link":"/2016/08/27/fetch/"},{"title":"Node.js 使用formidable上传文件及接受POST数据","text":"formidable官方文档 安装1$ npm install formidable 使用12var formidable=require(\"formidable\");var form=formidable.IncomingForm(); APIform的属性及方法 encoding 设置字符集 默认UTF-8 uploadDir 默认文件上传缓存位置 默认为OS_TEMP位置 type 选择接受是multipart还是urlencoded的Content-Type请求头 默认全部 我之前写过一篇介绍 HTTP头Content-Type 的文章 maxFieldSize 限制文件大小 默认 2mb 单位 字节 maxDields 限制header Format长度 默认为1000 为0则不限制 multiples 一次上传多个文件 默认为false 需要在input标签设置HTML5属性 multiple hash bytesReceived 目前接收到的字节数。 bytesExpected 预定总大小 字节 parse(req,[cb]) req 是HttpIncomingMeassage对象 cb 为callback函数 function(err,field,files) err 错误 field 对象 是http请求Format的键值对即application/x-www-urlencoded内容 files 接收到的文件对象（当接受多个文件时为一个数组） files.size 文件大小 单位是字节 files.path 缓存的目录及名字 files.name 上传时候的文件名 files.type 文件后缀类型 image/gif之类 files.mtime 最后修改时间 事件form.on('event',function(){}) progress .on(‘progress’,function(bytesReceived,bytesExpected){}) field .on(‘field’,function(name,value){}) fileBegin .on(‘fileBegin’,function(name,value){}) file .on(‘file’,function(name,file){}) error .on(‘error’function(err){}) aborted .on(‘aborted’,function(){}) end .on(‘end’,function(){}) DEMO客户端demo.html 12345 &lt;form action=\"post\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\" multiple=\"multiple\"&gt; &lt;input type=\"text\" name=\"zhang\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 服务端app.js 12345678910111213141516var http = require(\"http\");var express = require(\"express\");var app = express(); app.use(express.static('public',{\"index\":\"demo.html\"}));var formidable = require(\"formidable\");app.post('/public/post', function(req, res) { var form = new formidable.IncomingForm(); form.encoding = \"utf-8\"; form.uploadDir = __dirname + '/tmp'; form.multiples = true; form.parse(req, function(err, field, files) { files.field = field; res.json(files); console.log(files); })}) 运行1$ node app.js 添加字段和要上传的文件即可获得返回的json数据同时控制台输出json数据源码Node.js 使用formidable上传文件及接受POST数据","link":"/2016/01/02/formidable/"},{"title":"flex布局语法简介--转自阮一峰网络日志","text":"阮老师这篇flex布局语法篇讲述的非常详细，我对flex布局入门全靠这篇文章。原文地址 我把这篇文章保存成了pdf 预览/下载","link":"/2016/08/20/flex/"},{"title":"重制果儿岛商城By AngularJS","text":"前言本项目全部采用果儿岛提供的api，其中省略了支付宝付款这个功能，即不能替代原本官方商城进行商品支付。使用了angular1.5.8 使用bower管理依赖。采用 rem 实现自适应。以及css media query控制实现响应式布局。部分页面使用flex布局。 源码github Demohttp://fruit.garychang.cn 新窗口打开 使用123456git clonebower installnpm install 没有使用各种开发/测试插件，就 nginx 配合 livereload 插件。 项目结构12345678910- controller - //所有的controller- page - //route跳转的页面- static - //静态文件- template - //组件- app.js- index.html 主要页面 商品详情页面 地址管理页面 登陆页面 主页面 我的订单页面 用户中心页面 商店地址管理页面 购物车页面 组件 弹窗组件 轮播组件 header组件 漂浮的购物车按钮组件 预览","link":"/2016/09/22/fruit-angular/"},{"title":"generator-promise","text":"generator 函数和 promise 对象的结合使用当使用generator函数进行“流程管理”或使用koajs时候，往往需要使用异步操作。 123456789101112fun asyncF(){ return new Promise(function(resolve,reject){ resolve('ok'); })}//asyncF 函数是一个promise对象var g=function*(){ var F=yield asyncF(); console.log(F);}//g是一个generator 函数 这样就可以在generator函数中使用promise了。 在 koajs 中使用promise参考链接 var koa = require('koa'), app = koa(); app.use(function *() { var city = yield geolocation.getCityAsync(this.req.ip); //geolocation.getCityAsync是一个异步操作 var forecast = yield weather.getForecastAsync(city);//也是一个异步操作 this.body = 'Today, ' + city + ' will be ' + forecast.temperature + ' degrees.'; }); app.listen(8080);","link":"/2016/10/16/generator-promise/"},{"title":"Go学习笔记","text":"包程序运行入口是 main 包 1package go 导入使用 import 导入包 1234import ( \"fmt\" \"math/rand\") 可以一次导入多个包 导出首字母大写是被导出的 12345678package mainimport ( \"fmt\" \"math\")func main(){ fmt.Println(math.Pi)} 这里 PrintLn 和 Pi 首字母大写 函数函数可以没有参数或者接受多个参数 1234567891011package mainimport \"fmt\"func add(x int,y int) int{ return x+y}func main(){ fmt.Println(add(1,2))} 这里会做设定变量类型设定，类型在变量名之后， 在大括号前做返回类型设定 函数可以返回多个值，如果连续多个函数参数都是同种类型，则类型判定可以写在最后 1234567891011package mainimport \"fmt\"func swap(x,y string)(string,string){ return y,x}func main(){ a,b :=swap(\"hello\",\"world\") fmt.Println(a,b)} 上面的 a,b:=xxxx类似解构复制 命名返回值在函数大括号前的返回类型设定可以直接命名返回值，并且若返回值类型相同，类型也可以写在最后函数体内的 return 可以没有参数，此时会返回哥哥变量的当前值，此种方法被称为裸返回，返回的变量的名称应当有一定意义。 123456789101112package mainimport \"fmt\"func split(sum int)(x,y int){ x=sum *4 /2 y=sum-x return }func main(){ fmt.Println(split(20))} 变量使用 var 定义一个变量列表，类型在变量后面，var 可以写在包或者函数内当定义变量时候没有初始化赋值，会赋值 零值 数值类型为 0 布尔类型为 false 字符串为 “” 空字符串 123456789101112package mainimport \"fmt\"var js, c, java boolvar golang intfunc main() { var i int fmt.Println(i, js, c, java, golang)}// 0 false false false 0 初始化变量定义变量时候可以包含初始值 12var i,j int=1,2var c,py,java=true,false,\"java8\" 如果初始化变量时候使用表达式，则可以省略定义类型，变量直接从初始值中获取类型 短声明变量函数中 :=简介赋值语句在明确类型的地方可以代替 var 的定义，其不能用在函数外 123456789package main import \"fmt\"func main(){ var i,j=1,2 k:=3 c,py,java:=true,false,\"java8\" fmt.Println(i,j,k,c,py,java)} 打包声明同打包引入一样，变量也可以打包声明 1234var ( j int =1 i =3) 基本类型 bool string int int int8 (byte) int16 int32 (rune) int64 uint uint8 uint16 uint32 uint64 uintptr float32 float63 complex64 complex128 当无特别理由时候，定义整数类型时，首选 int 类型转换直接使用‘基本类型方法’转换即可，例如 12var i int=42var f float64 =float64(i) go 需要显式转换或者使用 := 12i:=42f:=float64(i) 123456package mainimport \"fmt\"func main(){ } 类型推导在下面这个例子中，使用了类型推导 i:=42 这里i为int类型，当为浮点数时，这个类型推导取决于赋值的常量精度。此时使用 fmt.Printf会返回变量类型 123456789package mainimport \"fmt\"func main() { v := \"232eqw4\" fmt.Printf(\"type %T\\n\", v)}//type string 上面这个 %T\\n 会对返回的值做一次处理，不加上的话会返回 1type%!(EXTRA string=232eqw4)% 常量常量使用 const 定义 for循环go只有一种循环。for 循环 12345678910package mainimport \"fmt\"func main(){ sum:=0 for i:=0;i&lt;10;i++{ sum+=1 } fmt.Println(sum)} 和js很像，只是没了 for 后面的条件语句的括号，并且这个初始化语句和后置语句都是可选的。 12345678910package mainimport \"fmt\"func main(){ sum:=0 for ;i&lt;10;{ sum+=1 } fmt.Println(sum)} 省略分号当省略分号时候，for循环即变成了 “while”循环 12345678910package mainimport \"fmt\"func main(){ sum:=0 for i&lt;10{ sum+=1 } fmt.Println(sum)} if语句同for语句，if语句也不需要把条件用括号括起来。并且在条件语句中执行的简单语句作用域在其花括号之内，也可以在其对应的else块中使用 switch语句同if语句，其执行顺序是从上到下，当匹配成功时候停止执行，当switch没有设置条件时候等同于设置了 switch true，然后可以在case里面写判断条件，类似于 if else if else 1234567891011121314151617package mainimport ( \"fmt\" \"time\")func main() t:=time.Now() switch { case t.Hour()&lt;12: fmt.Println(\"good morning\") case t.Hour&lt;17: fmt.Println(\"good afternoon\") default : fmt.Println(\"good eveneing\") } defer语句defer语句会延迟函数的执行，直到上层函数返回,延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用 12345678910package mainimport \"fmt\"func main(){ defer fmt.Println(\"world\") fmt.Println(\"hello\")}// hello world defer 栈延时调用的函数会被压入到一个栈中，当函数调用时，会按照后进先出顺序 1234567891011package mainimport \"fmt\"for i:=0;i&lt;10;i++{ defer fmt.Println(i)}fmt.Println(\"start\")// start// 9876543210 指针&amp; 符号会生成一个作用其对象的指针， * 符号表示指针指向其底层的值 123456789101112package mainimport \"fmt\"func main(){ i:=13 p:=&amp;i fmt.Println(*p) //13 *p=233 fmt.Println(i) //233 fmt.Println(*p) //233} 结构体struct 就是一个字段的集合，和js的对象相似 12345678910111213package mainimport \"fmt\"type Vertex struct{ X int Y int Z int}func main(){ v:=Vertex{1,2,4} fmt.Println(v.X) //1 } 通过 . 来读取和写入 结构体指针12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"type Vertex struct { X int Y int}func main() { v := Vertex{1, 2} p := &amp;v p.X = 3 fmt.Println(v) fmt.Println(*p)}//{3,2}//{3,2}package mainimport \"fmt\"type Vertex struct { X int Y int}func main() { v := Vertex{1, 2} p := v p.X = 3 fmt.Println(v) fmt.Println(p)}//{1,2}//{3,2} 这里go和js第对象处理不同，js对象是引用传递的（默认就是传指针） 数组12345678910package mainimport \"fmt\"var a [10]int //10个整数的数组func main(){ var b [2]string b[0]=\"hello\" b[1]=\"world\" fmt.Println(b[0],b[1]) //hello world} 数组slice可以通过以下方式赋值 12345package mainfunc main(){ a:=[]int{1,2,3,4,5}} 这里的slice可以理解和数组的项，数组的slice也可以为一个slice，这样就可以是多维数组 对slice切片1234567891011121314151617181920package mainimport \"fmt\"func main() { s := []int{2, 3, 5, 7, 11, 13} fmt.Println(\"s ==\", s) //[,2,3,5,7,11,13] fmt.Println(\"s[1:4] ==\", s[1:4]) //[2,3,7] // 省略下标代表从 0 开始 fmt.Println(\"s[:3] ==\", s[:3]) //[2,3,5] // 省略上标代表到 len(s) 结束 fmt.Println(\"s[4:] ==\", s[4:]) //[11,13]} 这里slice用法和js相同。 构造 sliceslice可以由函数 make 创建。会分配一个全是零值的数组并返回一个slice指向这个数组 1a:=make([]int,5) //len(a)=5 make函数接受三个参数， 1b:=make([]int,0,5) //len(b)=0 cap(b)=5 这里cap是内建函数 容量 nil sliceslice 的零值是 nil 一个nil 的slice的长度和容量是0 向slice末尾添加元素使用内建函数 append,类似于js push 123456789101112131415161718192021package mainimport \"fmt\"func main(){ var a[]int; printSlice(\"a\",a); a=append(a,0); printSlice(\"a\",a); a=append(a,1); printSlice(\"a\",a);}func printSlice(s string,x []int){ fmt.printf(\"%s len=%d cap=%d %v\\n\", s,len(x),cap(x),x)}// a len=0 cap=0 []// a len=1 cap=2 [0]// a len=2 cap=2 [0,1] rangefor 循环的 range 格式可以对 slice 或者 map 进行迭代循环。 当使用 for 循环遍历一个slice时，没戏迭代range将返回两个值，一个是当前slice下标，一个是该下标对应元素的一个拷贝。 12345678910111213141516package mainimport \"fmt\"var pow = []int{1, 2, 3, 4}func main() { for i, v := range pow { fmt.Println(i, v) }}// 0 1// 1 2// 2 3// 3 4 这里如果要忽略索引值可以把 i 换成 _ ，如果需要忽略value值，则把 v 和前面逗号删除即可。 mapmap 映射键到值 map在使用之前必须用make来创建；值为 nil 的 map 是空的，并且不能对其赋值。 1234567891011121314151617181920package mainimport \"fmt\"type Vertex struct { x, y int}var m map[string]Vertexfunc main() { m = make(map[string]Vertex) m[\"index\"] = Vertex{ 1, 2, } fmt.Println(m[\"index\"]) fmt.Println(m)}//{1,2}//map[index:{1,2}] map有点像对象数组 map 语法map语法和结构体语法类似，不过必须有键名。 123456789101112131415161718192021222324package mainimport \"fmt\"type Vertex struct { x, y int}var m = map[string]Vertex{ \"index1\": Vertex{ 1, 2, }, \"index2\": Vertex{ 3, 4, },}func main() { fmt.Println(m) fmt.Println(m[\"index2\"])}// map[index1:{1,2} index2:{3,4}]//{3,4} 这里看到 map 和js中的对象是非常类似的。但是注意是每个 “键值对” 末尾都要有逗号，结构体也是 操作map在 map m中插入或者修改一个元素 1m[key]=elem 获取元素 1elem=m[key] 删除元素,使用内建函数delete 1delete(m,key) 通过双赋值检测某个键是否存在 1elem,ok = m[key] 如果key在m中，则ok为 true，否则，ok为false，并且elem值是map这个元素类型的零值。同样的，当从map中读取某个不存在的键是，结果是map的元素类型的零值。 函数的闭包Go函数可以是一个闭包。闭包是一个函数值，他引用了函数体之外的变量。这个函数可以对这个引用的变量进行访问赋值。","link":"/2017/04/08/golangstudy/"},{"title":"gulp配合BrowserSync实现实时刷新","text":"BrowserSync安装 1npm install browser-sync -g BrowserSync 自带了静态文件服务器并且使用websocket实现实时刷新，还可以多端进行同时操作，例如手机端和PC端同时打开一个网页，手机端滚动，PC端回跟着滚动，也可以配合gulp或者grunt使用，我对gulp熟悉一点，这里使用gulp。 gulp配置文件及功能注释 1234567891011121314151617181920212223//gulpfile.jsvar gulp = require(\"gulp\");var browserSync = require(\"browser-sync\").create();var reload=browserSync.reload; //引入自动刷新gulp.task('browser-sync', function() { browserSync.init({ //初始化 BrowserSync injectChanges:true, //插入更改 files: [\"*.html\", \"*.css\", \"*.js\"], //监听文件类型来自动刷新 server: { baseDir: \"./xxx\" //目录位置 }, ghostMode: { //是否开启多端同步 click: true, //同步点击 scroll: true //同步滚动 }, logPrefix: \"browserSync in gulp\", //再控制台打印前缀 browser: [\"chrome\"], //运行后自动打开的；浏览器 port: 80 //使用端口 }); gulp.watch(['*.html', '*.css', '*.js'], {cwd: 'canvas'}, reload); //gulp监听的文件更改});gulp.task(\"default\",[\"browser-sync\"]); //使用default 控制台直接运行gulp即可","link":"/2017/01/11/gulpBrowsersync/"},{"title":"利用deviceorientation事件获取手机姿态","text":"兼容性 api首先在三位空间内正常拿着手机 x 轴方向由左向右， y 轴从下到上， z 轴垂直于手机屏幕向外。 alpha 围绕着z轴旋转与 y 轴（往往是正北方向）角度差。 beta 围着x轴旋转与水平线角度差。 gamma 围着y轴旋转时改变。 absolute 表示设备是否返回一个绝对值。 compassCalibreated 表示设备指南针是否被校准过。 demo新窗口打开 demo图片环境：安卓chrome-dev 53 源码1234window.addEventListener(\"deviceorientation\",function(event){ var console=document.getElementById(\"console\"); console.innerHTML=\"Z轴：\"+event.alpha+\"&lt;/br&gt;X轴：\"+event.beta+\"&lt;/br&gt;Y轴：\"+event.gamma; });","link":"/2016/08/30/gyrscope/"},{"title":"利用手机姿态使用websocket控制客户端css长方体姿态","text":"前言我之前有篇文章写了利用deviceorientation事件获取手机姿态。既然可以获取手机在三位空间内的与坐标轴角度，也就可以通过这来控制网页中css长方体的姿态。至于在两个网页/客户端传输数据，当然是用websocket最好了。这里刚好我之前做过两个小demo关于这个。 CSS3 3D立方体 使用websocket 的ws库构建聊天室 思路这个 Demo 分为客户端，控制端和服务端。客户端是一个用css3写的三维的长方体，只接受websocket数据。 控制端使用deviceorientation事件来获取手机姿态并通过websocket发送姿态数据。服务端就是一个使用ws库的websocket 服务器，这里我监听的端口是5656。 bug这里有个问题就是Z轴在临界值会直接从180°变成-180°，Y轴会在临界值从 90°变成-90°，我想了很久也没有找到解决方法，有好的解决方法可以提issues 使用源码地址 gyrscope-control-css-cube 1234git clone https://github.com/GaryChangCN/gyrscope-control-css-cube.gitnpm installnpm start//之后修改客户端和控制端 websocket 协议的地址为你服务端所在的局域网地址","link":"/2016/08/31/gyrscopeDemo/"},{"title":"使用hexo+github pages 搭建个人博客","text":"需要环境hexo是一个静态博客生成器，包括当前这个博客，很多博客也是由此构建，类似的构建工具还有jekyll这里只做hexo教程。由于hexo是基于node.js构建的，所以需要nodejs的运行环境。 网上已经有很多教程了，但是我还是自己写一下吧 安装node.jsmac 安装 使用brew 1brew install nodejs 官网下载 nodejs官网 windows 安装 官网下载安装包 nodejs官网 安装完成后使用命令 12node -vnpm -v 查看是否有版本号即可指导是否安装ok npm是nodejs的包管理软件。 安装hexohexo是用nodejs编写的静态博客生成器。具体使用教程在官网下面我只讲解怎么简单使用 1npm install hexo-cli -g 使用命令创建博客目录(myblog) 1234hexo init myblog //这一步是初始化myblogcd myblog //进入目录npm install //安装依赖hexo server //启动测试服务。默认监听在4000端口 此时访问 localhost:4000 即可查看到博客 编写文章1hexo new aricleName //这里是文章名 之后会在sorece-&gt;_posts目录下看到这个文章的源文件。采用markdown编写。 hexo更多api以及使用方式请查看官方文档 配置github pagesgithub pages 仓库和普通仓库相同。只有名字不同。例如 仓库名为 xxxx.github.io 这里xxxx最好是自己的github名字，且不唯一，这里我已经用过了，所以提示重复。 之后创建仓库即可 上传到静态文件到github pages首先需要安装hexo的git deployer插件，不然手动上传很麻烦官方文档hexo-deployer-git 按着官方文档安装配置即可。下面我会简要讲述安装配置过程。 1npm install hexo-deployer-git --save 打开博客根目录下的 _config.yml 配置文件，填写 1234deploy: type: git repo: git@github.com:shouDeveloper/shouDeveloper.github.io.git branch: master 这里repo应该填写刚刚创建的仓库的git地址。这里我用的ssh链接。如果没有配置ssh秘钥可以用https链接branch填写默认的master分支 保存 生成静态文件1hexo g //generator简写 上传到github pages1234hexo d //deploy简写//上述步骤简写hexo g -d 更多hexo api 见文档 更改博客主题 见主题不同主题也有不同的配置。详情见不同主题自己的文档。 访问浏览器输入刚刚仓库名 xxx.github.io 即可。例如上面我的是 garychangcn.github.io不过我这里用cname转到自己的域名了。","link":"/2017/05/26/hexoBlog/"},{"title":"前端实现图片转base64","text":"使用canvas 新建个canvas标签然后用css隐藏。之后获取此canvas元素，使用toDataURL方法转换。 12var canvas=document.getElementById(\"xxxx\");var base64=canvas.toDataURL(\"图片地址\"); 使用 FileReader使用 FileReader 的 readAsDataURL 方法，读取图片并把base64数据保存到其result属性中。 1234var reader=new FileReader();var file=fileList[0];//这里fileList是通过 File API 获取的文件数组（开启multi）reader.readAsDataURL(file);var base64=reader.result; 用途把图片转成base64形式用处主要是减少HTTP请求、实时预览要上传的图片。如果通过canvas的话还能做图片的进一步加工处理。","link":"/2017/01/04/img2base64/"},{"title":"实习","text":"2017-4-17 更新 快两个月了，现在已经很适应了，美团点评确实是符合我一切期望的大公司，里面同事都都很牛逼，自己学东西也可以非常快，感谢导师的各种不耐烦指导，期待毕业后正式入职的生活。这近两个月我学习了react及周边一大推东西，学习了导师自己开发的cmis框架，学习了go和react-native，写了个小程序 海大新媒体,之后这段时间就开始忙活毕业论文的事情了，不过应该没什么问题，毕竟我不写学术类，小程序项目前后端都写好了，理清思路写的应该很快。题外话：羡慕公司里（不限于新美大）那些华科团，清华帮，希望以后海大有更多的学弟学妹能到大公司工作实习。 之前内容 从2017年2月27日，到2017年3月30日，我在美团点评已经实习两周了。 从最初收到offer时候的兴奋到开始实习时觉得自己蠢的不行，直到今天还是觉得自己蠢的不行，不知道为什么，感觉脑子经常短路，有时候自己为什么加一个props或者为什么删uohe函数都不知道，不过这都不是最关键的，最关键的是我感觉自己在这两周确实学习了很多东西，也暂时在北京安顿下来了。 真正开始实习的时候我猜发现周围的人有多牛逼，也让我知道了很多牛逼的人是不喜欢混迹于各种程序员社区的，我要好好向他们学习，向我导师学习，这两周我一直都在学习React，基本上能使用React加周边工具写出一个Demo或者写各种组件，在这个期间（到刚刚）一直被我的导师各种指点，感谢我的导师不怎么嫌弃我蠢，与此同时我也学习的规范化代码以及规范化变量命名等等。 关于美团，美团点评符合我对大厂的一切希冀，有完整的员工管理体系，丰富的内部资源共享，在内部wiki上有很多前辈写的文章以及经验分享，有自己的git远程库和npm库，各种技术分享会和文章推送，mac确实好用，我都不怎么会用windows的快捷键了😆，另外还有”大象”这个很好的产品。我只想说能来到美团真的是我的幸运。我肯定会继续学习下去。 关于我的博客，这两周确实一篇博文也没写，也没把学习react上的问题写下来，之后会慢慢补，之前正在重写的毕业设计也没有写，主要原因是没有安顿下来，不过现在已经安顿下来了，我还会在下班的时候继续写代码写博客等等。","link":"/2017/03/11/interninmeituan/"},{"title":"koa2-formidable","text":"介绍简单封装的formidable在koa2的中间件。因为今天我把我的毕设后台从koa1升级到koa2了，全面使用async函数，所以之前用的koa-formidable就不合适了，索性就自己封装下。 使用1npm install koa-formidable --save 1234var formidable=require('koa2-formidable')var Koa = require('koa')var app =new Koa()app.use(formidable(opt)); 其中opt即是 formidable的options 源码koa2-formidable 123456789101112131415161718192021var formidable = require('formidable')module.exports=function (opt) { return async function(ctx,next){ var form=new formidable.IncomingForm(); for(let key in opt){ form[key]=opt; } await new Promise((reslove,reject)=&gt;{ form.parse(ctx.req,(err,fields,files)=&gt;{ if(err){ reject(err); }else{ ctx.request.body=fields; ctx.request.files=files; reslove(); } }); }); await next(); }}","link":"/2017/03/30/koa2-formidable/"},{"title":"简易仿制jQuery DOM处理","text":"前言这个文章我将会简单实现 jQuery 的 Dom 操作方法。其中并不会做兼容性处理只是技术实现。而且是直接操作DOM对象而非 jQuery 对象。而且我也没有实现事件委托 delegate 事件绑定方法 on，等等。 to-do-list [✔] 全局变量 [✔] html方法 [✔] text方法 [✔] 操作class方法 [✔] 遍历 [✔] 操作css方法 全局变量12345678910111213141516(function(window) { function _query(selector) { this.selector = selector; this.node = document.querySelectorAll(selector); this.nodes = Array.prototype.slice.call(this.node); } _query.prototype = { constructor: _query //这里写dom方法 } function init(selector) { return new _query(selector); } window._ = init;})(window); html方法12345678html: function(htmlString) { if (!!htmlString) { this.nodes.forEach(function(e) { e.innerHTML = htmlString.toString(); }); } return this.nodes[0].innerHTML;} text方法123456789text: function(txtString) { if (!!txtString) { this.nodes.forEach(function(e) { e.textContent = txtString.toString(); }); } else { return this.nodes[0].textContent; }} 操作class方法123456789101112131415161718192021222324hasClass: function(c) { return this.nodes.some(function(e) { if (e.className.split(\" \").indexOf(c) &gt;= 0) { return true; } });},addClass: function(c) { this.nodes.forEach(function(e) { e.className = e.className + \" \" + c; }); return this; //链式调用},removeClass: function(c) { this.nodes.forEach(function(e) { var classList = e.className.split(\" \"); e.className = classList.filter(function(item) { if (item != c) { return true; } }).join(\" \"); }); return this;} 遍历包括 parent parents prev prevAll next nextAll children 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107parent: function() { var parent = this.nodes[0].parentNode; //这里没有做父元素nodeType类型判断 this.nodes = [parent]; return this;},validElement: function(query, ele) { //这个函数类似于querySelector，因为我没有找到数组转 DOMCollection的方法，就写个这个方法 //来简单替代，用于 parents、find、nextAll、prevAll带查询参数时候。 var first = query.charAt(0); var name = query.slice(1); switch (first) { case \"#\": if (ele.id == name) { return true; } break; case \".\": if (ele.className.split(\" \").indexOf(name) &gt; -1) { return true; } default: if (ele.tagName.toLowerCase() === query.toLowerCase()) { return true; } else { return false; } }},parents: function(select) { var node = this.nodes[0], list = [], i = 1; while (node.parentNode.tagName.toLowerCase() !== \"html\") {//一直遍历到body元素 if (i !== 1) { list.push(node); } i++; node = node.parentNode; }; if (!!select) { var _this = this; this.nodes = list.filter(function(e) { return _this.validElement(select, e); }); } else { this.nodes = list; } return this;},children: function(select) { var node = this.nodes[0]; var list = Array.prototype.slice.call(node.children);//这里未使用childNodes然后做nodeType判断 if (!!select) { var _this = this; this.nodes = list.filter(function(e) { return _this.validElement(select, e); }); } else { this.nodes = list } return this;},next: function() { this.nodes = [this.nodes[0].nextElementSibling]; return this;},nextAll: function(select) { var node = this.nodes[0], list = [], next = node.nextElementSibling; while (!!next) { list.push(next); next = next.nextElementSibling; } if (!!select) { var _this = this; this.nodes = list.filter(function(e) { return _this.validElement(select, e); }); } else { this.nodes = list } return this;},prev: function() { this.nodes = [this.nodes[0].previousElementSibling]; return this;},prevAll: function(select) { var node = this.nodes[0], list = [], prev = node.previousElementSibling; while (!!prev) { list.push(prev); prev = prev.previousElementSibling; } if (!!select) { var _this = this; this.nodes = list.filter(function(e) { return _this.validElement(select, e); }); } else { this.nodes = list } return this;} 操作css方法css 方法传入的参数分别士两个参数，或者一个对象，传入对象时候意味着可以一次修改多个style样式，若不存在第二个参数时候则使用 getComputedStyle 1234567891011121314151617css: function(a, b) { if (typeof a == \"string\" &amp;&amp; !b) { return window.getComputedStyle(this.nodes[0], null)[a]; } else if (typeof a == \"object\") { this.nodes.forEach(function(e) { for (var k in a) { e.style[k] = a[k]; } }); return this; } else if (typeof a == \"string\" &amp;&amp; typeof b == \"string\") { this.nodes.forEach(function(e) { e.style[a] = b; }); return this; }} 源码及使用下载 1234567&lt;!--引入--&gt;&lt;script src=\"_query.js\"&gt;&lt;/script&gt;&lt;!--使用--&gt;&lt;script&gt;_(\"p\").text(\"hello gary\");//和jquery语法相似 把$换成_&lt;/script&gt; 小结一直想动手实现 jQuery 但是迟迟没有动手，事实证明有时候还是不要眼高手低为好，我只是写了几个操作DOM和CSS 样式的方法，并且也没有考虑兼容性的问题就已经写了很多行，可见jquery还是很值得前端学习的，无论是它自带的基础函数还是DOM\\CSS的兼容性处理都非常好，而且代码简洁多了。之后我会尝试使用 getter setter简单模仿 vue 实现 MVVM 框架。","link":"/2017/02/12/jquery/"},{"title":"canvas生成科赫雪花（曲线）","text":"科赫曲线 科赫曲线是一种外形像雪花的几何曲线，所以又称为雪花曲线，它是分形曲线中的一种，具体画法如下：1、任意画一个正三角形，并把每一边三等分；2、取三等分后的一边中间一段为边向外作正三角形，并把这“中间一段”擦掉；3、重复上述两步，画出更小的三角形。4、一直重复，直到无穷，所画出的曲线叫做科赫曲线。来自互动百科 思路使用js配合canvas生成科赫雪花。 效果新窗口打开 源码下载下载 源码及注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;科赫雪花&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"range\" id=\"range\" max=\"5\" min=\"1\" step=\"1\" value=\"1\"&gt; &lt;canvas id=\"canvas\" height=\"280\" width=\"280\"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; var canvas = document.getElementById(\"canvas\"); function koch(ctx, x1, y1, x2, y2, n, m) { //把每一边线段视为一个独立片段（例如当层级为1时候的） 如下面图示 //x1 x2 y1 y2 如下面图示 //n为当前的层数 //m为设定层级，建议不要太卡，浏览器会崩溃 ctx.clearRect(0,0,400,400); //每次绘图前清除画板 //以下是根据x1,x2的坐标获取 x3,x4,x5坐标。 如以下图示。 var x3 = (x2 - x1) / 3 + x1; var y3 = (y2 - y1) / 3 + y1; var x4 = (x2 - x1) / 3 * 2 + x1; var y4 = (y2 - y1) / 3 * 2 + y1; var x5 = x3 + ((x2 - x1) - (y2 - y1) * Math.sqrt(3)) / 6; var y5 = y3 + ((x2 - x1) * Math.sqrt(3) + (y2 - y1)) / 6; n++; if (n == m) { //绘图（连线） 当当前层级与设定层级一致时候停止递归 ctx.moveTo(x1, y1); ctx.lineTo(x3, y3); ctx.lineTo(x5, y5); ctx.lineTo(x4, y4); ctx.lineTo(x2, y2); ctx.stroke(); return false; } //递归调用绘图 koch(ctx, x1, y1, x3, y3, n, m); koch(ctx, x3, y3, x5, y5, n, m); koch(ctx, x5, y5, x4, y4, n, m); koch(ctx, x4, y4, x2, y2, n, m); } function draw(deep) { var ctx = canvas.getContext(\"2d\"); ctx.strikeStyle=\"#000\"; ctx.beginPath(); //以下是绘出初始的三条边的顶点位置（x1，x2） var y=80+Math.cos(Math.PI/6)*200; koch(ctx,150,y,250,80,0,deep); koch(ctx,250,80,50,80,0,deep); koch(ctx,50,80,150,y,0,deep); } draw(1); var range=document.getElementById(\"range\"); range.onchange=function(){ var r=~~range.value; draw(r) }&lt;/script&gt;&lt;style&gt; body { text-align: center; } #canvas { background-color: #fff; }&lt;/style&gt;&lt;/html&gt; 片段图示 参考文章参考文章","link":"/2017/01/06/koch/"},{"title":"实现一个lazyMan","text":"今天年初一，鸡年大吉@所有人 前言之前有看到lazyMan面试题。这里我写实现一次看看。lazyMan应该是用单例模式来实现。 特点 需要一个队列来保存事件 保存事件到队列 一个next方法来进行下一个事件 链式调用 感觉仅仅是为了多个异步循环的话还是用递归或者Promise.all()方便 代码实现效果 12345678910111213141516LazyMan(\"gary\"); //Hi this is gary!LazyMan(\"gary\").sleep(3).eat(\"dinner\");// Hi this is gary!// Wake up after 3s!// Eat dinner !LazyMan(\"gary\").sleepFirst(2).eat(\"dinner\");// Hi this is gary!// Eat dinner !// Wake up after 2s!LazyMan(\"gary\").sleep(2).eat(\"supper\").sleep(1).eat(\"dinner\")// Hi this is gary!// Wake up after 2s!// Eat supper !// Wake up after 1s!// Eat dinner ! 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function $LazyMan(name) { this.tasks = []; var _this = this; var fun = (function(n) { var name = n; return function() { console.log(`Hi this is ${name}!`); _this.next(); } })(name); this.tasks.push(fun); //把事件加入到队列中 setTimeout(function() { _this.next(); //下次eventLoop 启动任务 }, 0);}$LazyMan.prototype.next = function() { var fn = this.tasks.shift(); //获取当前队列中第一个并且删除队列中第一个 fn &amp;&amp; fn(); //执行};$LazyMan.prototype.eat = function(food) { var _this = this; var fun = (function(food) { return function() { console.log(`Eat ${food} !`); _this.next(); } })(food); this.tasks.push(fun); return this; //链式调用};$LazyMan.prototype.sleep = function(time) { //单位秒 var _this = this; var fun = (function(time) { return function() { setTimeout(function() { console.log(`Wake up after ${time}s!`); _this.next(); }, time * 1000); } })(time); this.tasks.push(fun); return this;};$LazyMan.prototype.sleepFirst = function(time) { var _this = this; var fun = (function(time) { return function() { setTimeout(function() { console.log(`Wake up after ${time}s!`); }, time * 1000); _this.next(); } })(time); this.tasks.unshift(fun); //推入 return this;};function LazyMan(name) { //封装 return new $LazyMan(name);}LazyMan(\"gary\"); //Hi this is gary!LazyMan(\"gary\").sleep(3).eat(\"dinner\");// Hi this is gary!// Wake up after 3s!// Eat dinner !LazyMan(\"gary\").sleepFirst(2).eat(\"dinner\");// Hi this is gary!// Eat dinner !// Wake up after 2s!LazyMan(\"gary\").sleep(2).eat(\"supper\").sleep(1).eat(\"dinner\")// Hi this is gary!// Wake up after 2s!// Eat supper !// Wake up after 1s!// Eat dinner ! 小结可见这个过程还是很简单的。主要考察的就是流程控制。 参考资料本文参考了文章 如何实现一个LazyMan","link":"/2017/01/29/lazyMan/"},{"title":"在koa1.0中使用mongoose的Promise","text":"在mongoose使用Promisemongoose的Promise使用起来还是很方便的只要在查询语句后面根成exec()方法即可。 例如 1db.User.findOne({}).exec() 这时候返回的即是一个Promise对象。 在koa中使用Promise只需在promise前面加上 yield 即可获取promise reslove时候的结果，如果需要捕获promise reject结果需要把整个语句放入try-catch中 例如 123456try{ var a=yield db.User.findOne({}).exec(); this.body=a;}catch{ this.body=\"false\";} 当然yield之后的promise可以用then()方法再return一个promise对象，当然这些都是promise里面东西。 其他在实际项目中有个问题当时困扰了我很久就是mongoose的objectId()尽管用http返回后显示的是一个字符串且值就是_id但是实际上他还是一个object，当然之后我使用toString()方法转成字符串后使用mongodb的查询对象是没问题的，但是如果不变成字符串，使用mongodb操作对象例如 $pull $push $in 是不行的，还有就是使用view做渲染时候也是不行的。","link":"/2016/12/10/mongoosePromise/"},{"title":"使用media query 实现响应式布局","text":"media query 概念media query 即是媒介查询，可以根据浏览器的不同特性来应用不同的css样式。例如： 123&lt;link href=\"css/reset.css\" rel=\"stylesheet\" type=\"text/css\" media=\"screen\" /&gt;&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\" /&gt;&lt;link href=\"css/print.css\" rel=\"stylesheet\" type=\"text/css\" media=\"print\" /&gt; 或者 12345&lt;style type=\"text/css\" media=\"screen\"&gt; *{ padding: 0px; }&lt;/style&gt; 以下我只讨论使用 screen 特性 media query screen例子例如 1&lt;link rel=\"stylesheet\" href=\"style.css\" media=\"screen and (min-width:640px) and (max-width:1080px)\"&gt; 或者 1234567&lt;style&gt; @media screen and (min-width:640px) and (max-width:1080px)\"{ *{ padding:0px; } }&lt;/style&gt; 都意味着当屏幕大小为640px和1080px之间时候，使用style.css样式，或者此media query 内样式。当然除了 and 也有 only 这个限制条件。 使用media query 是响应式布局的核心，所以我们通过限定不同屏幕/浏览器宽度而应用不同样式，来实现响应式设计。 Demo新窗口打开 这里我限定了四个宽度 大于1024px 560px和1024px之间 320px和560px之间 小于320px 分别对应的demo布局如下图 相关文章使用rem来做页面适配","link":"/2016/08/19/media query/"},{"title":"node.js 操作 mongodb 以及 mongoose 使用","text":"node.js 操作 mongodb首先引入 mongodb，然后打开数据库xxx,之后进入mycoll 集合。 1234var mongo = require(\"mongodb\");var server = new mongo.Server('127.0.0.1', '27017');var db = new mongo.Db('xxx', server);var mycoll=db.getCollection('mycoll'); 之后操作都会在 mycoll 对象上进行。 查找文档在mongo shell 中主要有两个方法，其中find方法会返回一个 cursor 对象，可以使用其toArray 方法转成数组。findOne 方法只会返回查找到的第一个元素。 1234567myColl.find({id:1},function(err,doc){});myColl.findOne({id:1},function(err,doc){}); 添加文档同使用mongo shell基本相同，如下： 12345678myColl.insert({ id:1, name:\"zhangsan\", age:\"18\"},function(err,result){}); 删除文档123myColl.remove({id:1},function(err,result){}); 保存文档.save() 方法可以让操作数据库变得简单些，查找过得到后的数据修改后可以直接保存。 123456myColl.findOne({id:1},function(err,doc){ doc.name=\"lisi\"; myColl.save(doc,function(err,result){ });}); 更新文档123myColl.update({id:1},{$inc:{age:1},{$rename:{name:'namename'}}},{upsert:true,multi:true},function(err,result){}); update方法接受四个参数。 第一个参数是一个query对象。 第二个参数是update，支持原子操作符。 第三个参数是option设置，可选 upsert（不存在时候创建）和multi（匹配到的多个都更新） 其中运算符有下列 运算符 功能 $inc 给指定片段指定增加或者减少的值 $rename 重命名字段 $setOnInsert 在更新时候设置字段值 $set 设置已经有的文档字段值 $unset 从已经有的字段中删除字段 $ 占位符 $addToSet 在数组中添加元素，若数组本身无此元素 $pop 删除数组第一个（值为-1）或者最后一个（值为1）元素 $pullAll 从数组中删除多个值，要删除的值以数组方式来指定 $pull 从数组中删除和查询条件匹配元素 $push 往数组中添加元素 $each 往数组中添加多个元素，以数组方式 $slice 用于限制更新后数组长度 $sort 排序 $bit 对整数进行按位与和或运算 使用mongoose操作mongodbmongoose可以操作数据库更方便点，除了官方文档，没有什么详细的中文文档，英文文档我看的太吃力了，以下总结了几个常用的操作。 SchemaSchema 是mongoose最特别地方，可以让文档整齐。 1234567891011var mongoose=require(\"mongoose\");var Schema=mongoose.Schema;var userSchema=new Schema({ name:{ type:String, default:'zhangsan' }, age:Number, array:Array}); mongoose Schema 支持以下类型 mongoose 官方文档 Schema Types String Number Date Buffer Boolean Mixed Objectid Array 其中Type options 支持一些例如default、trim等有用的配置 required: boolean 或者函数,当为true时候，会给其属性添加必填验证。 default: 默认值。 select: boolean值，设置查询时候映射 详情 `validate: required 设置所用 get get钩子。tips： Object.defineProperty() set set钩子。 lowercase: boolean, 小写。 uppercase: boolean, 大写。 trim: boolean, 使用trim方法。 match: RegExp, 产生一个验证器。 更多可以查看官方文档。 Model模型可以说是Schema 的实例，用于操作数据库。 123var User=mongoose.model('user',userSchema);//其第一个参数会作为集合名称。当其首字母大写收集合名为负数（-s）。 创建文档123456789var doc=new User({ name:\"zhangsan\", age:18, array:[1,2,3]});doc.save(function(err,result){}); 修改文档这里修改文档是指对集合的更新、查找、删除操作，因为这里 User 相当于上文中 myColl 所以操作方法是相同的。 给Schema添加方法给Schema添加方法可以减少代码书写量。 123456789101112userSchema.methods.findName=function(callback){ console.log(\"被使用\"); return this.model('user').find({name:this.name},callback);}var User=mongoose.model('user',userSchema);var f=new User({name:'zhangsan'});f.findName(function(err,results){}); 给Schema添加静态方法。上面给Schema添加方法需要新建个模型实例传入参数来为schema方法传入参数，而且值能通过这个实例f来使用自定义方法，不是很方便。可以使用下面方法给其添加静态方法。 12345678910userSchema.staticss.findName=function(name,callback){ //console.log(\"被使用\"); this.find({name:name},callback);}var User=mongoose.model('user',userSchema);User.findName('zhangsan',function(err,result){}); mongoose本身自带很多方法，具体可以查看官方文档","link":"/2016/10/26/mongoose/"},{"title":"多房间聊天室","text":"演示新窗口打开 源码github Doc中文 English 多房间聊天室多房间聊天室，首次进入需要创建个昵称（关闭浏览器会清除昵称），之后可以选择创建一个房间，或者加入一个房间，加入房间需要输入房间号。 使用工具 socket.io react及周边 使用启动服务器 1cd server &amp;&amp; yarn start websocket 服务端口在 3333 启动客户端（开发版本） 1cd client &amp;&amp; yarn run dev 客户端在端口9900 构建客户端 1cd client &amp;&amp; yarn run build 构建后的目录在 client/dist下 chat-roomMulti-room chat room, you should enter nickname at the first time when you use this project,and nickname will be cleared if close the browser. After enter nickname, you can choose createa room or join a room. Room number is needed when join a room. Build by socket.io react,redux,react-redux,react-router Usagerun server 1cd server &amp;&amp; yarn start websocket port on 3333 run client（development version） 1cd client &amp;&amp; yarn run dev client port on 9900 build client 1cd client &amp;&amp; yarn run build LICENSEMIT","link":"/2017/07/26/multiRoomChat/"},{"title":"使用 electron 编写 rethinkdb 管理软件","text":"Nirethink采用技术栈 electron react typescript mobx blueprintjs 源码地址github Develop12npm install // or yarn addnpm run no production 12npm install // or yarn addnpm run prod package 12npm install // or yarnnpm run package","link":"/2017/10/29/nirethink/"},{"title":"node.js内容管理系统","text":"node-CMS由node.js书写企业内容管理系统 来源由我和 JxJayden 共同开发的企业内容管理系统。此版本移除了七牛云密钥及加密密钥，并以 .demo.js做结尾。 源码node-CMS 使用12345678910111213git clone https://github.com/GaryChangCN/node-CMS.gitcd f2e/admin &amp;&amp; npm installcd server &amp;&amp; npm installcd f2e/admin &amp;&amp; npm run dev (npm run build)cd server &amp;&amp; npm run rendercd server &amp;&amp; node schedule.js#之后需要配置 `nginx` 根据 `/api`前缀反向代理本地 `3000` 端口。默认代理 `3001` 渲染端口。#并设置`admin.xxx.xxx` (管理页面)静态文件目录为 `vue` 打包后目录。#首次使用需要 cd server &amp;&amp; npm run initAdmin 来初始化超级管理员数据库。#如需启用备份数据库 则使用 cd server &amp;&amp; node schedule.js 默认为每晚23点备份到本地，#每周日23点上传最后次备份到七牛云。 架构前端分为用户端和管理员端。其中管理员端使用 vue2.0 配合 elementUI 的单页应用，由vue-cli搭建，用户端使用 jQuery 配合 arTemplate 多页网站，由gulp做相关处理。预编译器全部采用 less 。 后端分为渲染端和API端。全部使用 koa1.0 处理。采用mongoose连接数据库。 特点因本项目为专门公司定制，所以功能相对比较特殊化，但作为基础CMS系统，文章管理、商品管理、分组管理、管理员管理、订单（询单）管理,还是存在的。 特殊化网站支持中英文切换，支持保存订单（询单）到PDF（使用phantomjs），支持页面样式修改（包括不限于图片文字修改）,用户端为响应式设计仅适配PC和移动端。 API 说明后台api说明 渲染api说明 声明此开源项目bug修复会落后 private 版本一段时间，另外不详细解释项目部署问题（因为目前能力有限不会做自动化部署） 已知问题 koa-cookie 和 session 中间件会生成一个加密和一个不加密的 cookie 这里我使用 node.js 自带的加密模块做加密。 elementUI 1.0.0 版本数据更改但表格渲染会有延迟，通过改变两次中英切换简单解决。","link":"/2016/12/22/nodeCms/"},{"title":"nodejs的EventEmitter","text":"EventEmitter这里我观看了 @Richard Gong 的node.js高级编程03：events对象以及查阅书籍做出的简单模仿（ES6写法）。 构造首先新建个名字为 EventEmitter 的 class 。之后给其添加属性以及原型方法。 12345678910111213141516171819202122232425262728class EventEmitter { constructor() { this._events = { } } emit(type) { var funL = this._events[type]; var args = Array.from(arguments).slice(1); funL.forEach(function(e) { e(...args); }) } addListener(type, func) { this._events = this._events || {}; if (!this._events[type]) { this._events[type] = []; } this._events[type].push(func); } removeListener(type,func){ this._events[type].splice(this._events[type].indexOf(func),1); } on(type, func){ this.addListener(type, func) }} 上述代码中。on 和 addListener 本质上是一样的； 使用首先实例化 EventEmitter 然后添加监听事件以及触发事件。 123456789101112131415var emitter = new EventEmitter();emitter.addListener('test', function(a1, a2) { console.log(a1+a2); });emitter.on('test', function(a1, a2) { console.log(a2);});emitter.emit('test', \"augument1\", \"argument2\");emitter.emit('test', \"augument3\", \"argument4\");//console// augument1argument2// argument2// augument3argument4// argument4 源码源码","link":"/2016/12/15/nodejsEventEmitter/"},{"title":"拍拍贷爬虫","text":"需求前段时间发现了 superagent 这个库，发现比我之前使用的 request 这个库方便多了，准备把我的毕设的爬虫端用这个重写来着，但是看完文档一直没动手，直到同学让我帮他爬个数据，然后我就写了个爬虫。 dependencies使用了 superagent 获取获取然后使用 jsdom 解析，后期使用了 node-xlsx 来把json转为xls格式。 源码&amp;Useagepaipaidai-spider 小总结这个爬虫我分了两个部分。整个过程还是很简单的，获取url存到数组里-&gt;保存成json-&gt;读取json根据url获取页面信息-&gt;保存成json-&gt;json转xls。 第一部分第一部分我先获取每个投资单的url，这里非常简单，就是改变分类页的页号然后获取这个页面下所有的链接的 href 特性值，然后使用Promise.all来解决多重异步循环。 第二部分获取投资单url后，即可获取每个页面上的具体信息，这里有两个坑爹的地方，第一个就是若用户没有详细信息，这个页面的布局就不同，此时用class获取的dom集合的顺序不同，一开始我都没有发现，后来才发现。第二个坑点是我没想到获取页面会失败的情况，本来也准备用 Promise.all 的，然后有可能会卡住，然后我就用递归。 插曲开始运行运行爬虫的时候不知道爬到第几个页面了，然后我就加个进度栏（格式[205/20000]）就看着爽多了😆。","link":"/2017/01/21/paipaidai-spider/"},{"title":"setState异步问题","text":"关于setState因为react的setState是个异步方法，所以有些时候可能会导致ui响应不及时或者不能通过state来准确的上传数据。这里可能需要把setState转变成同步方法 回调官方文档上面描述 1setState(updater, [callback]) 其第二个参数是回调函数，可以通过回调来调用函数。并且第一个参数也可以数函数形式，这个函数会返回“预修改”后的值。 123this.setState((prevState, props) =&gt; { return {counter: prevState.counter + props.step};}); async await首先写个方法来封装setState成Promise 12345678function promiseSetState (state){ var _this=this; return new Promise((resolve,reject)=&gt;{ _this.setState(state,()=&gt;{ resolve(); }); });} 之后用async函数调用 async function(){ await promiseSetState({value:null}); }","link":"/2017/04/21/react-setSate/"},{"title":"react-typescript-template","text":"readmeA mouth ago. I have write two cli/templte 两个template.But react-typescript-webpack-cli has a big problem, too slow to compile, so I have refactor the code. The reason of “Why do you write this article in english?” is that I want to improve my english.I’ll insist on writing though there will be a lot of grammatical mistakes. reason of slowBecause I had use ts-loader to compile .tsx files, It will waste too much time when first time tostart webpack-dev-server or build by webpack. how to sloveUse tsc watch .ts files change and compile immediately. So webpack can receive js files as entry, andts-loader is nolonger needed.When build application, run tsc commander then use webpack to package js files. If environment isproduction, use babel compile .es6 to .es5 and compress it with uglifyJsPlugin. nokitI have use nokit as my command line tools, Use it can be very convenientto spawn or exec command. It was develop by my mentor. source codereact-webpack-typescript-cli usege dev 1yarn run dev production will convert to es5 and minify 1yarn run production tree caglog12345678910111213141516├── dist│ ├── bundle.js│ ├── index.html│ └── src│ ├── index.js│ └── moduleA.js├── nofile.js├── package.json├── readme.md├── src│ ├── moduleA.js│ └── moduleA.tsx├── tsconfig.json├── tslint.json├── webpack.config.js└── yarn.lock","link":"/2017/08/31/react-typescript-template/"},{"title":"react+webpack+typescript配置","text":"目录结构&amp;地址12345678├── dist├── node_modules├── package.json├── src ├── index.tsx├── tsconfig.json├── webpack.config.js└── yarn.lock 模板文件地址及使用 package.json1234567891011121314151617181920212223\"devDependencies\": { \"babel-core\": \"^6.24.1\", \"babel-loader\": \"^7.0.0\", \"babel-preset-es2015\": \"^6.24.1\", \"babel-preset-react\": \"^6.24.1\", \"babel-preset-stage-0\": \"^6.24.1\", \"css-loader\": \"^0.28.1\", \"jsx-loader\": \"^0.13.2\", \"less\": \"^2.7.2\", \"less-loader\": \"^4.0.3\", \"style-loader\": \"^0.17.0\", \"ts-loader\": \"^2.0.3\", \"typescript\": \"^2.3.2\", \"webpack\": \"^2.4.1\", \"webpack-dev-server\": \"^2.4.5\" }, \"dependencies\": { \"@types/react\": \"^15.0.23\", \"@types/react-dom\": \"^15.5.0\", \"prop-types\": \"^15.5.8\", \"react\": \"^15.5.4\", \"react-dom\": \"^15.5.4\" } 这里需要注意的是安装了 @types/react和@types/react-dom。 tsconfig.json1234567891011121314{ \"compilerOptions\": { \"outDir\": \"./dist/\", \"sourceMap\": true, \"noImplicitAny\": true, \"module\": \"commonjs\", \"target\": \"es5\", \"jsx\": \"react\", \"allowJs\": true }, \"exclude\": [ \"node_modules\" ]} webpack.config.js123456789101112module: { rules: [{ test: /\\.(jsx|js)$/, use: [{ loader: \"babel-loader\" }] }, { test: /\\.(tsx|ts)$/, loader:\"ts-loader\", exclude:\"/node_modules/\" }]}, webpack用的是2.0 .babelrc123{ \"presets\": [\"es2015\", \"react\", \"stage-0\"]}","link":"/2017/05/04/react-webpack-typescript/"},{"title":"redux-form笔记","text":"前言这是我在学习redux的文档记得笔记，没有教程意义。 简单的例子123456789101112131415161718192021222324252627282930313233343536//simpleform.jsxclass SimpleForm extends Component { render(){ return( &lt;form onSubmit={this.props.handleSubmit}&gt; &lt;Field component=\"input\" name=\"m\"/&gt; &lt;button type=\"submit\"&gt;click&lt;/button&gt; &lt;/form&gt; ) }}export default reduxForm({ form:'simpleForm'})(SimpleForm);//index.jsximport SimpleForm form 'simpleform.jsx';import {reducer as reduxFormReducer} from 'redux-form';import {combineReducers,createStore} from 'redux';import {Provider} from 'react-redux';var reducer=combineReducers({ form:reduxFormReducer});var store = createStore(reducer);class Index extends Component { render(){ return( &lt;Provider store={store}&gt; &lt;SimpleForm onSubmit={(value)=&gt;{console.log(value)}}/&gt; &lt;/Provider&gt; ) }} 主要方法在reduxForm 里，其会注入很多方法，包括handleSubmit。 renderField Factory可以使用一个函数方便的生成div+label+input 1234567891011121314151617class renderField extends Component { render(){ var {input, label, type, meta}=this.props; var {touched,error,warning}=meta; return ( &lt;div&gt; &lt;label&gt;{label}&lt;/label&gt; &lt;div&gt; &lt;input {...input} type={type}/&gt; {touched&amp;&amp;((error &amp;&amp; &lt;span&gt;{ error }&lt;/span&gt;) || (warning &amp;&amp; &lt;span&gt;{ warning }&lt;/span&gt;))} &lt;/div&gt; &lt;/div&gt; ) }}&lt;Field component={renderField} type=\"text\" label=\"username\"/&gt; 这里可以看到 input props 会包含在Field 设置的name value 等props。meta则是reduxForm注入的。 验证 验证规则默认是blur时候触发 可以写在reduxForm()方法中 123456789101112const validate=(value)=&gt;{ const errors={} if(value.xxx){ errors.xxx=\"这里写上验证失败返回字段\" } return errors;}reduxForm({ form:'12ty', validate, warn //warn与valiate相同}) 也可以直接写在“行内” 123456789101112const needEnglish=(value)=&gt;{ if(/[a-z]{1,}/.test(value)){ return null; }else{ return \"need English\"; }}const required=(value)=&gt;{ return value?null:\"Required\";}&lt;Field component=\"input\" validate={[required,needEnglish]} warn={}/&gt;//warn同理 写在submit中，在onSubmit中判断 异步验证在 reduxForm({}) 声明 asyncValidate 函数,以及声明asyncBlurFields为要在blur时候触发异步验证的field 123456789101112const sleep=(ms)=&gt;new Promise((reslove)=&gt;{ setTimeout(reslove,ms)});const asyncValidate=(value)=&gt;{ return sleep(1000).then(()=&gt;{ if(value.username==\"qwerty\"){ throw {username:\"can't ~~ qwerty\"}; } })} ** 这里asyncValidate函数返回的必须是一个 Promise对象 初始化表单reduxForm 会给 form 注入一个 initialvalues props，可以用connect对应到redux中的state来实现初始化数据 12345678910111213141516171819202122function mapStateToProps(state){ var state=state.initialForm; return { initialValues:state }}function mapActionToProps(dispatch){ return { load:function(data){ dispatch(loadAction(data)) } }}export default connect(mapStateToProps,mapActionToProps)( reduxForm({ form:'initialForm', validate, warn })(syncValidForm)) 上面代码中 loadAction是一个action Remote Submit 提交按钮独立出来123import {submit} form 'redux-form';//formname为reduxForm方法里传入的form名称&lt;button onClick={submit('formname')}&gt;submit&lt;/button&gt; props submitting 是够正在提交阶段（submit验证） reduxForm asyncBlurFields asyncValidate destoryOnUnmount enableReinitialize boolean 默认值的 false 当为true时候，每次initialValues props变化时候，form都会重新初始化，但是不能初始化 keepDirtyOnreinitialize设置的项 forceUnregisterOnUnmount * getFormState * keppDirtyOnReinitialize 与enabeReinitialize对应 initialValues 初始值，是个对象，可以用react-redux和store中state对应起来 onSubmit 当不存在handleSubmit时候替代用 onSubmitFail 当submission失败时候触发 onSubmitSuccess propNamespace pure 不懂 shouldValidate 控制是否进行同步验证,会传入一个参数，有以下属性 values nextProps props initialRender 需要返回true或者false控制是否进行验证 shouldAsyncValidate 控制是否进行一步验证，传入的参数不同 touchOnBlur boolean[true] 设置 fields touched 如果 没有blur事件 touchOnChange 同上 default为false persistentSubmitErrors boolean[false] 当change事件不存在时候不会移除submit errors validate warn 实例API是reduxForm指传入到组件中的props dirty:boolean当前值不和初始值（initialValues）相同时候为true invalid:boolean存在validation errors 即 true pristine和dirty对应 registeredFields:array一个数组储存着所有field的name和type信息的 reset:function重置表单到 initialValues submit:promisevalid:boolean和 invalid对应 values当前所有的field values wrappedInstance:ReactElement","link":"/2017/03/25/redux-form/"},{"title":"使用rem来做页面适配","text":"思路因为rem单位的特殊性，其是根据根元素&lt;html&gt;的字体大小来作为单位的，所以只需修改根元素的字体大小即可改变整个页面大小甚至是布局。 根据 mediaquery来设置通过css mediaquery 来限定不同屏幕宽度而设置根元素的字体大小来实现适配。 使用javascript判断 首先在头部加上 12&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; 其次使用js获得浏览器窗口宽度，这里我之前有篇文章详细说明了获取屏幕宽度 js获得浏览器宽高、屏幕宽高 其次把宽度除以10设为&lt;html&gt;的字体大小，即rem大小为十分之一浏览器窗口宽度 123456function setRem() { var width = document.documentElement.clientWidth ? document.documentElement.clientWidth : window.innerWidth; var rem = width / 10; document.querySelector(\"html\").style.fontSize = rem + \"px\";} 然后监听 resize 事件来实时改变 1234window.addEventListener(\"resize\", function() { setRem();}); Demo新窗口打开Demo","link":"/2016/08/17/rem/"},{"title":"js监听对象属性变化","text":"思路监听对象属性变化有两种方法：回调函数、使用访问器属性。首先定义一个对象 123var obj = { a:null} 回调函数使用回调函数思路是定义一个函数来设置对象的属性，之后在调用回调函数 定义监听函数1234567891011function $watch(obj, prop, callback) { if (!obj.$property) { obj.$property = function(prop, value) { if (this[prop] != value) { this[prop] = value; return callback(this); } return this; } }} 触发回调123$watch(obj,'a',function(obj){ console.log(\"obj的属性a的发生改变：\"+obj.a);}) 更改属性值1obj.$property('a','random') 访问器属性使用访问器属性即使用set get 属性，可以通过 Object 的 defineProperty 方法访问到。此方法有兼容性问题 ，这里我只监听属性更改，没有修改。 监听12345Object.defineProperty(obj,\"a\",{ set:function(val){ console.log(\"obj的属性a的发生改变：\"+val); } }); 更改属性值1obj.a='random';","link":"/2016/08/25/setgetcallback/"},{"title":"作业上传+学生互评打分系统","text":"安装1npm install 启动12mongod --dbpath xxxnode app.js 简介本项目采用 javascript + node.js + mongodb 开发完成。学生端采用了谷歌chrome应用商店配色以及我自己封装的 _Ajax库 。教师端使用了Jquery库和 Flex 布局\\以及采用了百度Echart。后端使用了node.js采用mongodb作为数据库。 界面预览 Github地址","link":"/2016/07/09/scroing/"},{"title":"js排序算法","text":"前言填之前的坑几种排序算法的javascript实现上篇文章只写了冒泡排序，插入排序和快速排序，这篇写一下其他的。 选择排序选择排序即是把数组中最小项移到数组第一项，然后从第二项开始到最后一项，把最小的和第二项交换…….. 12345678910111213function seleSort(arr){ let len=arr.length; for(let i=0;i&lt;len;i++){ for(let j=i;j&lt;len;j++){ if(arr[j]&lt;arr[i]){ let max=arr[i]; arr[i]=arr[j]; arr[j]=max; } } } return arr;} 希尔排序希尔排序是插入排序的优化，具体过程可以看这篇文章，讲的很清晰。排序四 希尔排序 12345678910111213function shellSort(arr){ let len = arr.length; for (let point = Math.floor(len / 2); point &gt; 0; point = Math.floor(point / 2)) { for (let i = point; i &lt; len; i++) { for (let j = i - point; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[point + j]; j -= point) { let temp = arr[j]; arr[j] = arr[point + j]; arr[point + j] = temp; } } } return arr;}","link":"/2017/06/15/sort/"},{"title":"使用vh vw来做页面适配","text":"vw vh 概念vw 即viewport width 的简写，意思是屏幕的宽度。100vw等于屏幕宽度。vh 即viewport height 的简写，意思是屏幕的高度。100vh等于屏幕高度。 vmax vminvmax 即 vw 和 vh 中比较大的那个。vmmin 即 vw 和 vh 中比较小的那个。 浏览器兼容性 页面适配思路同 rem 做页面适配相似。这里 10vw 等于十分之一屏幕宽度，和这篇文章中使用rem来做页面适配 1rem 等于 10vw。剩下的不变，而且不需要js判断来更改根元素的字体大小。","link":"/2016/08/21/vh vw/"},{"title":"viewport详解","text":"viewport概念viewport 是一个移动专属的 meta 值，用于设定“视窗口”的各种行为。因为css中的1px往往不等于移动设备中的1px，因为移动设备像素密度越来越高，所以后来就有移动设备上2px表示css中1px。例如 iphone5 的屏幕像素宽度是640px，在css中既是320px。总之 viewport 就像一个容器把原本比较大的屏幕挤到特定大小。 viewport 属性viewport一般形式如下 12&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; 其中content 内容为其属性。 width 值往往是一个正整数或者 device-width ，用于定于视窗口的宽度，单位为像素。 height 值也是一个正整数或者 device-height ，用于定义视窗口的高度，单位为像素。 initial-scale 值为 [0.0-10.0] 之间，用于定义初始缩放值。 minimum-scale 值为 [0.0-10.0] 之间，用于定义最小缩放比例，必须小于 maximun-scale 设置值。 maximum-scale 值为 [0.0-10.0] 之间，用于定义最大缩放比例，必须大于 minimum-scale 设置值。 user-sacleable 值为 yes/no ，用于确认用户是否能用手势缩放页面，默认为 yes 。","link":"/2016/09/04/viewport/"},{"title":"the-super-tiny-compiler","text":"很简单，这个文章就是 the-super-tiny-compiler 的翻译 我 fork 后仓库地址为 the-super-tiny-compiler-cn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855/*** 今天我们准备一起写个编译器。但是不是其他的一些编译器。。。是一个超级小巧的编译器！这个编译器小到* 如果你删除这个文件所有注释的话只剩不到200行代码** 我们准备吧一些 类似于 lisp 语法的函数编译成类似于 c 语法的函数** 如果你对他们其中一个或者全部了解，我下面将给你们一个简洁** 如果我们有两个函数 `add` 和 `substract` 我们书写方式如下** LISP C** 2 + 2 (add 2 2) add(2, 2)* 4 - 2 (subtract 4 2) subtract(4, 2)* 2 + (4 - 2) (add 2 (subtract 4 2)) add(2, subtract(4, 2))** 是不是很简单** 确切来说我们要编译的几部是完整的 lisp 或者 c 的语法，但是这个编译器还有有足够的语法去证明其是一个* 现代的编译器*//*** 大部分编译器把编译过着三个主要步骤：解析、转换、生成代码** 1. *解析* 把初始代码用更抽象的方式来表达** 2. *转换* 把抽象的语法变成编译器想要的样子** 3. *代码生成* 根据转换后的代码来生成新的代码*//*** 解析过程* -------** 解析过程通过分为两个阶段：词法分析和语法分析** 1. *词法分析* 把初始代码分解成很多部分，每个 token 被用标记器或者词法分析器来标识** token 是一段由用来描述把语法分割成块后的小对象组成的数组。他可以是数字、标记、* 标点符号、操作符或者其他东西** 2. 语法分析* 把 token 重新格式化成语法段互相之间的关系可以被表示的样子，可以理解为* 抽象语法树的中间态** 抽象语法树（AST) 是一种已递归的方式来表示代码同时又能展示出代码的巨量信息。** 例如下面的语法** (add 2 (subtract 4 2))** Tokens 会类似于下面代码** [* { type: 'paren', value: '(' },* { type: 'name', value: 'add' },* { type: 'number', value: '2' },* { type: 'paren', value: '(' },* { type: 'name', value: 'subtract' },* { type: 'number', value: '4' },* { type: 'number', value: '2' },* { type: 'paren', value: ')' },* { type: 'paren', value: ')' },* ]** 抽象语法树类似于以下代码** {* type: 'Program',* body: [{* type: 'CallExpression',* name: 'add',* params: [{* type: 'NumberLiteral',* value: '2',* }, {* type: 'CallExpression',* name: 'subtract',* params: [{* type: 'NumberLiteral',* value: '4',* }, {* type: 'NumberLiteral',* value: '2',* }]* }]* }]* }*//*** 转换* --------------** 编译器的下一个阶段是转换。这阶段会再次改变把上一步得到的的抽象语法树，他可以操作相同的语言* 的抽象语法书或者把其翻译成一个完整的新语言** 下面我们来看我们将如何转换一个抽象语法树** 你可以已经注意到我们的抽象语法树看起来非常简单。其中每抽象语法树节点都有 type 属性。每个* 节点都声明了一个属性来描述这个独立的节点** 我们现在有个类型为 NumberLiteral 的节点：** {* type: 'NumberLiteral',* value: '2',* }** 或者有个类型为 CallExpression 的节点：** {* type: 'CallExpression',* name: 'subtract',* params: [...nested nodes go here...],* }** 当转换抽象语法树的时候，我们可以通过 添加/删除/替换 节点的属性来操作节点。* 我们可以添加新的节点，删除节点，或者我们我们通过当前抽象语法树来创建一个新的* 抽象语法树。** 一旦我们选择好了要编译成目标语言，我们就要专注于创建一个针对这个目标语言的特殊的* 抽象语法树。** 遍历* ---------** 我了给这些节点创建个导航，我们需要使用深度优先遍历这个抽象语法树。** {* type: 'Program',* body: [{* type: 'CallExpression',* name: 'add',* params: [{* type: 'NumberLiteral',* value: '2'* }, {* type: 'CallExpression',* name: 'subtract',* params: [{* type: 'NumberLiteral',* value: '4'* }, {* type: 'NumberLiteral',* value: '2'* }]* }]* }]* }** 所以，对于上面的抽象语法树，我们应该这样做：** 1. Program - 从抽象语法树的最顶层开始* 2. CallExpression (add) - 移到 Program 的 body 的第一个元素上* 3. NumberLiteral (2) - 移动到 CallExpression's 的 params 第一个参数元素上* 4. CallExpression (subtract) - 移动到 CallExpression's 的第二个参数元素上* 5. NumberLiteral (4) - 移动到 CallExpression's 第一个参数元素上* 6. NumberLiteral (2) - 移动到 CallExpression's 第二个参数元素上** 如果我们直接操作抽象语法树而不是单独创建一个抽象语法树,我们可能需要说明这里所有的首相概念。* 但是对于我们来说 “参观” 一遍这些节点就足够了。** 这里我用 “参观” 这个词的原因是这里是一种代表操作对象结构的元素的一种方法** 参观者* --------** 这里我们有个基础的想法，创建一个 “参观者” 对象，其包含从不同节点类型传过来的方法** var visitor = {* NumberLiteral() {},* CallExpression() {},* };** 当我们遍历这个抽象语法树的时候，我们可以随时通过 “参观者” 调用方法无论何时我们 “进入” * 相匹配的节点** 为了使上述行为生效，我们需要传入 node 节点和 parent 节点的引用作为参数。** var visitor = {* NumberLiteral(node, parent) {},* CallExpression(node, parent) {},* };** 然后我们还是需要有种方式来推出。设想一下我们的树结构是这样一种结构** - Program* - CallExpression* - NumberLiteral* - CallExpression* - NumberLiteral* - NumberLiteral** 当我们便利到最下面的时候，我们需要接触到最后的分支。当我们遍历完每个树的分支后* 我们需要从中退出。所以，向下遍历我们需要 “进入”，返回时候我们需要 “退出”。** -&gt; Program (enter)* -&gt; CallExpression (enter)* -&gt; Number Literal (enter)* &lt;- Number Literal (exit)* -&gt; Call Expression (enter)* -&gt; Number Literal (enter)* &lt;- Number Literal (exit)* -&gt; Number Literal (enter)* &lt;- Number Literal (exit)* &lt;- CallExpression (exit)* &lt;- CallExpression (exit)* &lt;- Program (exit)** 为了支持以上，我们 “参观者” 最终结果如下：** var visitor = {* NumberLiteral: {* enter(node, parent) {},* exit(node, parent) {},* }* };*//*** 代码生成* ---------------** 这个编译器最后一部分是代码生成。有些时候编译器会在转换的过程里面做这件事，但是大部门代码生成器* 仅仅意味着把我们的抽象语法树编程最终代码** 代码生成器可以通过很多种方式来工作，一些编译器会重复使用早前的 “token” ，另一些会生成一个代码* 片段来代表这段代码，然后可以线性的打印出这些节点，但是这里我可以告诉大家，我们会使用我们刚刚创建* 的抽象语法树来生成代码** 我们的代码生成器会有效的 “打印” 抽象语法树上所有不同类型的节点，同时也会递归打印出这些代码变为* 字符串。*//*** 之后，我们就可以开始了，熊这个编译器的每个部分开始。** 事实上，不是所有的编译器都和我这里叙述的编译器类似。每个编译器都有不同的目的，所以他们可能有* 比我叙述的编译器拥有更多的步骤。** 但是现在你可以战歌一个更高的角度来概括一个编译器会长什么样。** 我已经标书这么多了，现在你准备好去写一个自己的编译器了吧？** 开个玩笑，我还是会在这里和你一起完成这个编译器的 :P** 所以，我们开始吧。。。*//*** ============================================================================* (/^▽^)/* THE TOKENIZER!* ============================================================================*//*** 我们开始解析过程的第一阶段，使用 tokenizer 词法分析。** 这一步要做的是字符串变成每项由 token 组成的数组** (add 2 (subtract 4 2)) =&gt; [{ type: 'paren', value: '(' }, ...]*/// 我们从接受一个名为 input 的字符串开始，之后将设置两个东西function tokenizer(input) {// `current` 变量用来追踪我们现在在代码中的的位置，类似于光标let current = 0;// `tokens` 数组用来存贮我们的 tokenlet tokens = [];// 我们从创建一个 while 循环开始，然后按着我们需要的长度来递增 current 变量//// 我们这样做的原因是 current 增加可能是多次的并且由于我们 token 的长度是任意的，所以// 其增加的长度也是任意的。while (current &lt; input.length) { // 我们同事来存贮 input 字符串的当前值 let char = input[current]; // 首先要租的事情是检查圆括号，之后将会被用到 `CallExpression` 中。 // 我们要检查是不是有左边开括号 if (char === '(') { // 如果是的，我们会把一个有 key 为 type 值为 paren 和 key 为 value 值为 ( // 的对象推入到 tokens 中 tokens.push({ type: 'paren', value: '(', }); // 之后递增 `current` current++; // 然后进入下次循环 continue; } // 之后我们要寻找右括号，然后重复上文的动作 if (char === ')') { tokens.push({ type: 'paren', value: ')', }); current++; continue; } // 移动后我们将检查空格及空白字符串，若匹配到则不作任何处理，光标继续后移 let WHITESPACE = /\\s/; if (WHITESPACE.test(char)) { current++; continue; } // 之后的 token 类型是 number 。这和我们刚刚处理的不同，因为我们需要截取一个整个 number // 来作为 token // // (add 123 456) // ^^^ ^^^ // Only two separate tokens // // 所以我们重新创建一个循环，当遇到第一个 number 是婚后 let NUMBERS = /[0-9]/; if (NUMBERS.test(char)) { // 我们创建一个 value 字符串来储存字符 let value = ''; // 之后我们创建一个循环来把连续的 number 储存在 value 中并增加 current 的值 while (NUMBERS.test(char)) { value += char; char = input[++current]; } // 之后我们把 number 类型的 token 储存起来 tokens.push({ type: 'number', value }); // 再进行下一次循环 continue; } // 我们同样支持用双引号包裹的字符串 // // (concat \"foo\" \"bar\") // ^^^ ^^^ string tokens // // 我们先开始检查左边的双引号 if (char === '\"') { // 使用 value 变量来创建字符串 token let value = ''; char = input[++current]; // 之后我们会储存每个字符直到下一个双引号 while (char !== '\"') { value += char; char = input[++current]; } char = input[++current]; // 把字符串 token 储存起来 tokens.push({ type: 'string', value }); continue; } // 最后一中 token 类型是命名 token，其实是作为 lisp 函数名的 // // (add 2 4) // ^^^ // Name token // let LETTERS = /[a-z]/i; if (LETTERS.test(char)) { let value = ''; // 我们讲再次循环每个单词然后把他们储存到 value 中 while (LETTERS.test(char)) { value += char; char = input[++current]; } // 把 name 类型保存起来，之后进入下次循环 tokens.push({ type: 'name', value }); continue; } // 最后如果没有匹配到任何特征，则会抛出错误 throw new TypeError('I dont know what this character is: ' + char);}// 最后，返回这个 tokens 数组return tokens;}/*** ============================================================================* ヽ/❀o ل͜ o\\ﾉ* 解析器!!!* ============================================================================*//*** 解析器是把刚刚得到的 token 数组解析成抽象语法树** [{ type: 'paren', value: '(' }, ...] =&gt; { type: 'Program', body: [...] }*/// 好了，我们这里定义一个 parser 函数，接受 tokens 数组function parser(tokens) {// 我们再次用一个 current 变量当作指针let current = 0;// 但是这次我们用递归来代替 while 循环，所以这里我们定义了一个 walk 函数function walk() { // 早函数内部我们根据 current 指针未知来获取 token let token = tokens[current]; // 现在开始把不同类型的 token 分割成不同的代码片段 // 从 number 类型的 token 开始 // // 我们检测是否有 number 类型的 token if (token.type === 'number') { // 如果检测到， 则把 current 加 1 current++; // 之后我们会返回一个新的抽象语法树节点，类型为 NumberLiteral 值为 token 的值 return { type: 'NumberLiteral', value: token.value, }; } // 同 number 类型， string 类型会返回一个类型为 StringLiteral 新的抽象语法树节点 if (token.type === 'string') { current++; return { type: 'StringLiteral', value: token.value, }; } // 之后我们需要寻找 CallExpressions 类型，所以我们从能匹配到左括号且类型为 paren 开始 if ( token.type === 'paren' &amp;&amp; token.value === '(' ) { // 我们将会往后移动 current 指针来跳过 括号 token = tokens[++current]; // 我们创建一个类型为 CallExpressions 的基础节点，之后我们将其 name 字段设置成当前 token // 的 value 值 let node = { type: 'CallExpression', name: token.value, params: [], }; // 之后再次移动 current 指针来跳过 name token token = tokens[++current]; // 现在我们希望循环每个 token 从左括号开始到右括号来作为 CallExpressions 的参数 // // 现在我们进入递归之中，为了防止无限的递归调用，我们需要一个结束的标志点 // // 为了解释上述，来看我们的 Lisp 代码，你可以看到 add 函数的参数是一个 number 类型和 // 一个 CallExpressions ，并且其有自己的返回值 // // (add 2 (subtract 4 2)) // // 你还会注意到我们的 tokens 数组会有很多右括号类型的 token // // [ // { type: 'paren', value: '(' }, // { type: 'name', value: 'add' }, // { type: 'number', value: '2' }, // { type: 'paren', value: '(' }, // { type: 'name', value: 'subtract' }, // { type: 'number', value: '4' }, // { type: 'number', value: '2' }, // { type: 'paren', value: ')' }, &lt;&lt;&lt; Closing parenthesis // { type: 'paren', value: ')' }, &lt;&lt;&lt; Closing parenthesis // ] // // 我们将递归调用 walk 函数来移动 current 指针直到遍历完所有的 CallExpressions // 所以我们创建一个 while循环，从左括号开始，直到匹配到第一个右括号才会结束 while ( (token.type !== 'paren') || (token.type === 'paren' &amp;&amp; token.value !== ')') ) { // 我们调用 walk 函数，其会返回一个节点，我们会将这个节点推入到 node.params 中 node.params.push(walk()); token = tokens[current]; } // 最后我们会移动 current 指针一直到右括号 current++; // And return the node. return node; } // 同样的，如果我们没有匹配到任何类型我们也会抛出错误 throw new TypeError(token.type);}// 现在我们开始创建抽象语法树，其会有一个类型为 program 的根节点let ast = { type: 'Program', body: [],};// 之后我们启动 walk 函数，把值推入到 ast 的body 中//// 之所以在 while 循环内部做这些事情，是因为有的函数不是嵌套的，可能是线性的//// (add 2 2)// (subtract 4 2)//while (current &lt; tokens.length) { ast.body.push(walk());}// 在解析器的最后我们将返回这个抽象语法树return ast;}/*** ============================================================================* ⌒(❀&gt;◞౪◟&lt;❀)⌒* THE TRAVERSER!!!* ============================================================================*//*** 现在我们已经得到了抽象语法树，但是我们系统能在一个 visitor 中获取到任意一个节点。我们需要* 一个方法当匹配到想要的节点时候会触发这个方法** traverse(ast, {* Program(node, parent) {* // ...* },** CallExpression(node, parent) {* // ...* },** NumberLiteral(node, parent) {* // ...* },* });*/// 所以我们定义了 一个 traverser 函数，其接受 ast 和 visitor 两个参数，// 在函数内部内有两个函数function traverser(ast, visitor) {// traverseArray 函数允许我们遍历完整个数组，并调用接下来定义的 traverseNode 函数function traverseArray(array, parent) { array.forEach(child =&gt; { traverseNode(child, parent); });}// `traverseNode` 接受 node 参数 和 node 的 parent 参数，所以我们可以把两者传给 visitorfunction traverseNode(node, parent) { // 我们从 visitor 存在的方法开始（node 的类型）类作为 methods 变量 let methods = visitor[node.type]; // 其如果存在并且存在 enter 方法，则调用这个方法，并把 node 和 parent 作为参数传入 if (methods &amp;&amp; methods.enter) { methods.enter(node, parent); } // 之后我们讲根据不同的节点类型类做不同的事情 switch (node.type) { // 在开始的网时候，我我们最顶层的是一个名为 Program 的对象，其有一个body属性来储存 // nodes 数组，我们调用 traverseArray 函数来把其传入进该数组 // // （记住 traverseArray 函数会调用 traverseNode 函数，所以我们可以递归来遍历整个树） case 'Program': traverseArray(node.body, node); break; // 之后我们对 CallExpression 类型做相同的事情，并且返回其 参数 case 'CallExpression': traverseArray(node.params, node); break; // 在这里， NumberLiteral 类型和 StringLiteral 类型没有后代元素，所以不做处理 case 'NumberLiteral': case 'StringLiteral': break; // 同样的，没有匹配到节点类型，则会抛出错误 default: throw new TypeError(node.type); } // 如果其还存在 exit 方法，我们则调用该方法并把 node 和 parent 当参数传入 if (methods &amp;&amp; methods.exit) { methods.exit(node, parent); }}// 最后我们调用 tarverserNode 函数并传入 ast 树作为 node 参数，之所以没有 parent 参数，// 是因为我们从最顶层开始traverseNode(ast, null);}/*** ============================================================================* ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽* 转换器!!!* ============================================================================*//*** 下一步，转换器，我们的转换器将通过把抽象语法树和 visitor 作为 traverse 函数参数来产生一个* 新的抽象语法树** ----------------------------------------------------------------------------* 原始 AST | 转换后的 AST* ----------------------------------------------------------------------------* { | {* type: 'Program', | type: 'Program',* body: [{ | body: [{* type: 'CallExpression', | type: 'ExpressionStatement',* name: 'add', | expression: {* params: [{ | type: 'CallExpression',* type: 'NumberLiteral', | callee: {* value: '2' | type: 'Identifier',* }, { | name: 'add'* type: 'CallExpression', | },* name: 'subtract', | arguments: [{* params: [{ | type: 'NumberLiteral',* type: 'NumberLiteral', | value: '2'* value: '4' | }, {* }, { | type: 'CallExpression',* type: 'NumberLiteral', | callee: {* value: '2' | type: 'Identifier',* }] | name: 'subtract'* }] | },* }] | arguments: [{* } | type: 'NumberLiteral',* | value: '4'* ---------------------------------- | }, {* | type: 'NumberLiteral',* | value: '2'* | }]* (sorry the other one is longer.) | }* | }* | }]* | }* ----------------------------------------------------------------------------*/// 所以我们的转换器接受 lisp 的抽象语法树function transformer(ast) {// 我们像以前一样创建一个有 Program 节点的新 astlet newAst = { type: 'Program', body: [],};// 之后我会使用一点 hack的方法，我们将使用一个名为 context 的属性在我们的父节点上然后我们可以// 把节点放到其父元素的的 context 上。按正常的方法，你可以把这步做的更好，但是我们的目的是把事情// 做的简单//// 仅仅需要记住 context 只是在新的 ast 树中对老的 ast 的引用ast._context = newAst.body;// 开始调用我们之前创建的 traverser 函数traverser(ast, { // 第一个 visitor 方法接受任何 NumberLiteral NumberLiteral: { // 我们将在 enter 方法中获取他 enter(node, parent) { // 我们讲创建一个同样名为 NumberLiteral 的新街点然后推送到父元素的 context 中 parent._context.push({ type: 'NumberLiteral', value: node.value, }); }, }, // 之后我们有 StringLiteral StringLiteral: { enter(node, parent) { parent._context.push({ type: 'StringLiteral', value: node.value, }); }, }, // 之后是 CallExpression CallExpression: { enter(node, parent) { // 我们创建一个名为 CallExpression 的新节点，其有嵌套的 Identifier let expression = { type: 'CallExpression', callee: { type: 'Identifier', name: node.name, }, arguments: [], }; // 之后我们将定义新的 context在原始的 CallExpression 节点，其代表着 // expression 的参数列表，所以我们可以把新 expression 添加进参数列表 node._context = expression.arguments; // 之后我们会检查父元素是不是 CallExpression // 如果不是的话。。。 if (parent.type !== 'CallExpression') { // 我们将会用 ExpressionStatement 把 CallExpression 节点包裹起来 // 这样做的原因是最 js 顶层的 CallExpression 时隔真实的语法声明 expression = { type: 'ExpressionStatement', expression: expression, }; } // 最后我们把 CallExpression （或 ExpressionStatement ） 推入到父元素的 context中 parent._context.push(expression); }, }});// 最后我们把这个新的抽象语法树返回即可return newAst;}/*** ============================================================================* ヾ（〃＾∇＾）ﾉ♪* 代码生成器!!!!* ============================================================================*//*** 现在，让我们进入最后一步：代码生成器** 我们的代码生成器将会递归调用自己来以正确的字符串形式打印出树的每个节点*/function codeGenerator(node) {// 我们根据节点的类型来操作switch (node.type) { // 如果遇到了 Program 节点，我们将会对其 body 中每个节点来使用代码生成器函数 // 来输出目标代码，最后是把代码换行 case 'Program': return node.body.map(codeGenerator) .join('\\n'); // 对于 ExpressionStatement 我们会调用代码生成器在嵌套的语法端上，并在末尾加上分号 case 'ExpressionStatement': return ( codeGenerator(node.expression) + ';' // &lt;&lt; (...因为我们希望代码能显示的好看一点) ); // 对于 CallExpression 我们将会打印出其 callee 和左括号，我们讲遍历参数列表，并把每项传入到 // 代码生成器中，并用逗号分割，最后加上右括号 case 'CallExpression': return ( codeGenerator(node.callee) + '(' + node.arguments.map(codeGenerator) .join(', ') + ')' ); // 对于标识符，我们只需要返回其 name 即可 case 'Identifier': return node.name; // 对于 NumberLiteral 我们只需要返回其值即可 case 'NumberLiteral': return node.value; // 对于 StringLiteral 我们要在两端加上双引号 case 'StringLiteral': return '\"' + node.value + '\"'; // 最后如果我们没有匹配到任何一项，则抛出异常 default: throw new TypeError(node.type);}}/*** ============================================================================* (۶* ‘ヮ’)۶”* !!!!!!!!编译器!!!!!!!!* ============================================================================*//*** 完工！我们创建好了我们的编译器函数，现在我们把上述过程列出来** 1. input =&gt; tokenizer =&gt; tokens* 2. tokens =&gt; parser =&gt; ast* 3. ast =&gt; transformer =&gt; newAst* 4. newAst =&gt; generator =&gt; output*/function compiler(input) {let tokens = tokenizer(input);let ast = parser(tokens);let newAst = transformer(ast);let output = codeGenerator(newAst);// 简单的输出就好了return output;}/*** ============================================================================* (๑˃̵ᴗ˂̵)و* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!结束了!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!* ============================================================================*/// 现在，仅仅导出所有东西module.exports = {tokenizer,parser,traverser,transformer,codeGenerator,compiler,};","link":"/2017/08/13/the-super-tiny-compiler/"},{"title":"使用websocket 的ws库构建聊天室","text":"更新现在开发了新版本 多房间聊天室 websockethtml5 新api，用于实现持久化连接，且不收跨域影响。通过HTTP 的Updrade头来升级协议。 使用方法1234567891011121314//创建实例var socket=new WebSocket(\"ws://localhost:xxxx\");//发送数据socket.send(\"hello world\");//接受数据socket.onmessage=function(event){ console.log(event.data)}//初始化事件socket.onopen=function(){}//关闭事件socket.onclose=function(){}//关闭连接socket.close() 服务端服务端这篇文章我使用了 ws 这个库。 1npm install ws --save Demo新窗口打开服务端随时可能关闭，仅供测试。 已关闭 tips这里我使用了 vw vh 来做屏幕适配，之后我的博客会有专门文章来写这个 Demo 问题 由于使用了 beforeunload 事件来从客户端结束连接，但是在移动端对 beforeunload 兼容性不好，会导致直接关闭浏览器/页面 连接会依然存在，这里以为朋友给我的建议是使用 心跳检测 之后我会有文章来单独写心跳检测。 Demo 思路用户设定昵称，此时传一个json数据给服务器告知新添用户，之后会返回一个对象包括欢迎当前用户以及在线列表，之后更改客户端状态，之后客户端发布消息不会添加用户而只会 广播 这个消息。之后注销/退出，会再次更改客户端状态，并告知服务器当前用户退出，服务端会广播此用户退出消息，以及更新用户列表。 ### 示例图以及示例代码 示例图片 部分代码详细代码可以在我的github查看 123456789101112131415&lt;div class=\"container\"&gt; &lt;div id=\"cover\"&gt; &lt;input type=\"text\" id=\"username\" placeholder=\"请输入昵称\"&gt; &lt;input type=\"submit\" id=\"ok\" value=\"确定\"&gt; &lt;/div&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;聊天室&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"user\"&gt; &lt;/ul&gt; &lt;form action=\"\"&gt; &lt;input type=\"text\" id=\"input\" required=\"required\"&gt; &lt;input type=\"submit\" value=\"submit\" id=\"submit\"&gt; &lt;/form&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041var socket = new WebSocket(\"ws://new.garychang.cn:7777\");document.getElementById(\"ok\").onclick = function() { var value = document.getElementById(\"username\").value; var name = value ? value : \"匿名\"; document.getElementById(\"cover\").style.display = \"none\"; msg.name = name; msg.log = 0; socket.send(JSON.stringify(msg)); msg.log = 1;}window.addEventListener(\"beforeunload\", function(e) { msg.log = 2; socket.send(JSON.stringify(msg)); socket.close(); var confirmationMessage = '确定离开此页吗？'; (e || window.event).returnValue = confirmationMessage; return confirmationMessage;});socket.onmessage = function(event) { var json = JSON.parse(event.data); ul.append(json.msg); var tmp = \"&lt;li&gt;当前成员&lt;/li&gt;\"; json.list.forEach(function(e) { tmp += \"&lt;li&gt;\" + e + \"&lt;/li&gt;\"; }); document.getElementById(\"user\").innerHTML = tmp;}window.onunload = function() { msg.log = 2; socket.send(JSON.stringify(msg)); socket.close();}socket.onclose = function() { socket.close();}document.getElementById(\"submit\").addEventListener(\"click\", function(event) { event.preventDefault(); msg.msg = document.getElementById(\"input\").value; socket.send(JSON.stringify(msg)); document.getElementById(\"input\").value=\"\";}); 12345678910111213141516171819202122232425262728293031323334var WebSocketServer = require(&quot;ws&quot;).Server;var wss = new WebSocketServer({ port: 7777 });var msg = { list: [], msg: null};wss.broadcast = function broadcast(data) { wss.clients.forEach(function each(client) { client.send(data); });};wss.on(&apos;connection&apos;, function connection(ws) { ws.on(&apos;message&apos;, function incoming(message) { var json = JSON.parse(message); if (json.log == 0) { msg.list.push(json.name); msg.msg = &quot;用户：&quot; + json.name + &quot;已加入房间&quot;; wss.broadcast(JSON.stringify(msg)); } else if (json.log == 1) { msg.msg = json.name + &quot;：&quot; + json.msg; wss.broadcast(JSON.stringify(msg)); } else if (json.log == 2) { var index = msg.list.findIndex(function(e, i, a) { if (e == json.name) { return i; } }); msg.list.splice(index,1); msg.msg=&quot;用户：&quot; + json.name + &quot;离开了房间&quot;; wss.broadcast(JSON.stringify(msg)); } });});console.log(&quot;websocket on 7777&quot;);","link":"/2016/08/19/websocketlibWS/"},{"title":"js获得浏览器宽高、屏幕宽高","text":"高度有关12345678910111213//浏览器窗口高度window.outerHeight//浏览器可视区域高（包括滚动条）window.innerHeight//ps：在部分版本QQ浏览器上innerHeight和outerHeight值相同//浏览器可视区域高（不包括滚动条）document.documentElement.clientHeight//网页总高度document.body.clientHeight//显示器可视高度window.screen.height//显示器可用高度（例如去除底部任务栏）window.screen.availHeight 宽度有关123456789101112//浏览器窗口宽度window.outerWidth//浏览器可视区域宽度（包括滚动条）window.innerWidth//浏览器可视区域宽度（不包括滚动条）document.documentElement.clientWidth//网页总宽度document.body.clientWidth//显示器可视宽度window.screen.width//显示器可用宽度（例如去除侧边任务栏）window.screen.availWidth 图片高度示意","link":"/2016/08/16/widthheight/"},{"title":"zara websocket based rpc lib","text":"zarazara is an rpc lib zara Usage install 123npm install zara --save// ...oryarn add zara server In Sandbox class, it will save env object when a client connect, different connection withdifferent env. env will contain userId in default, which is connection id. when disconnectsandbox will destory automatically. Then you shou pass ws listen port and Sandbox to Server function to start rpc. default portis 3189 12345678910111213141516171819import { Server } from 'zara'class Sandbox { private env = null constructor (env, ws) { this.env = env } async foo (p1, p2) { const res = await new Promise((resolve) =&gt; { setTimeout(function () { resolve(`${p1} ${p2}`) }, 1000) }) return res }}Server(3189, Sandbox) Client You should pass url to Client function, default url is ws://localhost:3189.you can invoke server function esaily though call function which is Clientclass instance object. Attention: in call function you must use template string. and the only wayto pass params is use ${} 12call`(fun hello world)` // wrongcall`(fun ${'hello'} ${'world'})` //correct 12345678910111213import Client from 'zara/dist/client'const url = 'ws://localhost:3189'const { call } = Client(url)(async () =&gt; { const p1 = 'hello' const p2 = 'world' const res = await call`(foo ${p1} ${p2} )` console.log(res) // hello world})() catch error in order to catch error you can add the follow code in server and client 123process.on('uncaughtException', (err) =&gt; { console.error(err)})or just use try...catch statement develop dev git clone https://github.com/GaryChangCN/zara.gitand npm install or yarn installthen npm run dev or yarn run dev build npm run build or yarn run build","link":"/2017/08/28/zara/"},{"title":"知乎日报vue2.0重构","text":"前言大约一年前用了vue1.0写了知乎日报,当时没有用vuex，而且url和view也没有一一对应，并且开源出来别人下载不一定跑的起来（后台代理问题），这次重构用了大约一天时间，使用vue2.0和vuex,基本没有使用vue-cli,自己配的webpack（中间有很多坑，还是vue-cli好用)。使用async/await并且把请求都分离出来方便开发。 知乎日报 vue2.0版开发框架：vue2.0全家桶(vue.js,vuex,vue-router)构建工具: webpackcss预编译工具: lessbabel:preset-es2015,stage-3,由于使用了 async/await，所以需要babel-polyfill 此版本不包括离线下载、查看评论、没有做错误处理等。 功能包括 查看最新消息 查看主题列表 查看主题内容 查看文章详情 预览&amp;源码使用vue1.0开发的版本已经停止维护和预览。2.0版本demo预览源码 使用1234git clone git@github.com:GaryChangCN/zhihu-daily-byVuejs.gityarn installyran run serveryarn run dev 在server.js中更改后端host地址。 APIapi来源于 @izzyleung 并使用node.js进行二次封装， 项目灵感来源于 @hilongjw API使用，所有uri格式相同除了把host改成了本地 localhost:9999 tips图片会提示图片只允许在知乎使用 我目前没有好的解决方式，若直接使用api返回的图片地址，知乎会直接返回403，我这里使用了node来代理更改referer头获取图片。使用方式是新建一个全局filter image。 vue1.0 截图2.0版本LicenseMIT","link":"/2017/05/08/zhihuDaily-vue2/"},{"title":"用vue简单实现知乎日报","text":"前言使用版本vue1.x。想用vue构建知乎日报原因很简单，作为一个vue小白很需要亲手做个项目来提升提及以及更加深入了解vue，也希望这个小项目能给刚学习vue的同学一点启发。 准备工作首先要找到知乎日报的api，这里感谢 @izzyleung 总结的知乎日报api以及说明 因为原来的api不支持跨域嘛，需要自己代理这些api并允许跨域，这里我只代理了8个接口，接口以及参见本项目github的readme。之后再用nginx来反向代理接口。 开发过程项目参考了vue官方提供的参考项目，使用了 vue-router 和 vue-resource 这两个插件，并且使用了vue-cli 这个脚手架工具来搭建webpack项目。之后就可以正式开发了，UI我大致模仿了知乎日报安卓客户端的UI但是没有实现其全部功能，以后会慢慢完善。对于vue的核心，组件部分，我这里写了6个组件，分别是导航栏组件、侧边栏组件、主页组件、轮播组件、主题列表组件、文章组件，考虑到要模仿客户端UI，这里组件样式全是用sass/css写的。我这里偷懒，响应式布局只写了最外面的container在屏幕宽度大于640px时候宽度调整为640px并且水平居中，所以建议在手机或F12手机模式下浏览demo，另外由于采用了flex布局，请使用现代浏览器。之后就是规划路由啦，然后做做简单的CSS3动画效果，demo就完工了，之后把demo上传到我1M带宽的小水管服务器上，静态文件挂在七牛云上，解决。 （Tips：使用sublime的同学可以下载vue syntax highlight 这个插件来语法高亮.vue文件，但是，当你把 &lt;style&gt;加上lang=&quot;sass &quot;时，emmet语法会失效，我的解决方式是sublime右下角暂时更改语法模式为html，另外格式化.vue代码用HTML-CSS-JS Prettify插件并在其配置文件中加上vue即可）。 图片防盗链当我遇到知乎日报图片防盗链时候我是拒绝的，因为一直提示403，我不能确定是webpack-dev-server出问题还是nginx出问题或者是知乎封了我等等，后来发现如果我挂上ss，或者直接本地打开项目文件，图片是能正常打开的，然后我就意识到是防盗链问题，我的解决方式是用node来转发这些图片并更改请求referer头为www.zhihu.com然后问题就解决了，这里有个**花絮**：开始我把node http.Request 里面url对象的pathname写成了pathnnme然而我还没有发现导致返回的图片一直是本图片仅限在知乎内使用balabala的，我以为是服务器ip被封都放弃了，在上次检查时发现了这个bug然后图片就能正常显示了。 项目地址Demo http://zhihu.garychang.cnGithub https://github.com/GaryChangCN/zhihu-daily-byVuejs 部分截图","link":"/2016/07/28/zhihudaily/"},{"title":"js设计模式","text":"目录 前言 单体模式 工厂模式 迭代器模式 装饰者模式 策略模式 外观模式 代理模式 中介者模式 观察者模式 前言本文参考于《javascript模式》，因此会大量内容会和书中相同，手上有这本书的朋友可以直接看书。因为我的记忆习惯是抄书，所以我会先抄写下来再发到博客上。 单体模式单体模式思想在于保证一个特定类仅有一个实例，意味着当你第二次使用同一个类创建信对象时，应得到和第一次创建对象完全相同。 方法一123456789101112function Universe(){ if(typeof Universe.instance===\"object\"){ return Universe.instance; //防止被篡改 } this.xx=\"xx\"; Universe.instance=this; return this;}var uni=new Universe();var uni2=new Universe();uni===uni2; //true 缺点instance 属性暴露。 方法二使用闭包 1234567891011function Universe(){ var instance=this; //缓存this this.xx=\"xx\"; Universe=function(){ //重写此构造函数 return instance; }}var uni=new Universe();var uni2=new Universe();uni===uni2; //true 缺点因为重写了构造函数，constructor 还是指向了老的构造函数,且实例化后在添加原型属性也是不一样的。如下 1234567var uni = new Universe();Universe.prototype.a = 1var uni2 = new Universe();console.log(uni === uni2) //trueconsole.log(uni.a) //undefindedconsole.log(uni2.a) //undefindedconsole.log(uni.constructor === Universe); //false 方法三解决方法二问题。 12345678910function Universe(){ var instance; Universe=function Universe(){ return instance ; } Universe.prototype=this; //保存原型属性 instance=new Universe(); instance.constructor=Universe; instance.xx=\"xx\";} 方法四自运行函数。 12345678910111213141516171819var Universe;(function(){ var instance; Universe=function Universe(){ if(instance){ return instance; } instance=this; this.xx=\"xx\"; }})();var uni = new Universe();Universe.prototype.a = 1var uni2 = new Universe();console.log(uni === uni2) //trueconsole.log(uni.a) //1console.log(uni2.a) //1console.log(uni.constructor === Universe); //true 工厂模式工厂模式是为了创建对象。 例子 公共构造函数 CarMaker 名为factory的CarMaker静态方法来创建car对象 123456var corolla=CarMaker.factory('compact');var solstice=CarMaker.factory('convertible');var cherokee=CarMaker.factory('suv');corolla.drive() //I have 4 doorssolstice.drive() //I have 2 doorscherokee.drive() //I have 6 doors 实现12345678910111213141516171819202122232425function CarMaker() {}CarMaker.prototype.drive = function() { return \"I have \" + this.doors + \" doors\";}CarMaker.compact = function() { this.doors = 4;}CarMaker.convertible = function() { this.doors = 2}CarMaker.suv = function() { this.doors = 6;}CarMaker.factory = function(type) { if (typeof CarMaker[type] !== \"function\") { throw \"Error\" } if (typeof CarMaker[type].prototype.drive !== \"function\") { CarMaker[type].prototype = new CarMaker(); } var newCar = new CarMaker[type](); return newCar;}var corolla = CarMaker.factory('compact');console.log(corolla.drive()); //I have 4 doors 内置工厂对象Object() 构造函数即为内置工厂对象。 迭代器模式有一个包含某种数据集合的对象，该数据可能存储在一个复杂数据结构内部，而要提供一个简单方法讷讷感访问到数据结构中没一个元素。 next() 下一个 hasNext() 是否有下一个 reWind() 重置指针 current() 返回当前 1234567891011121314151617181920212223242526272829var agg = (function() { var index = 0; var data = [1, 2, 3, 4, 5, 6]; var length = data.length; return { next: function() { //这里是从第一个数据开始输出 本例中为 1 if (!this.hasNext()) { return null; } var element = data[index]; index++; return element; }, hasNext: function() { return index &lt; length; }, reWind: function() { index = 0; }, current: function() { return data[index]; } }})();while (agg.hasNext()) { console.log(agg.next()); //1,2,3,4,5,6}agg.reWind(); //此时重置指针到0 装饰者模式可以在运行时候添加附加功能到对象中，他的一个方便特征在于其预期行为的可定制和可配置特性。 例子 假设在开发一个销售商品的Web应用，每一笔信销售都是一个人新的 sale 对象。该对象“知道”有关项目的价格，并可以通过 getPrice() 方法返回加个。根据不同情况，可以用额外的功能装饰此对象。假设客户在魁北克省，买房需要支付联邦税和魁北克省税，则此时需要调用联邦税装饰者和魁北克省税装饰者。 12345var sale=new Sale(100);sale=sale.decorate(\"fedtax\"); //联邦税sale=sale.decorate(\"quebec\"); //魁北克省税sale=sale.decorate(\"miney\"); //转为美元格式sale.getPrice(); //返回价格 并且装饰是可选的，例如不再魁北克省有可能没有省税。 方法一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function Sale(price) { this.price = price;}Sale.prototype.getPrice = function() { return this.price;};Sale.decorators = {}; //储存装饰者的对象//装饰者Sale.decorators.fedtax = { getPrice: function() { var price = this.uber.getPrice(); return price * 0.8; //对price进行处理 },}Sale.decorators.quebec = { getPrice: function() { var price = this.uber.getPrice(); return price * 0.7; //对price进行处理 },}Sale.decorators.money = { getPrice: function() { var price = this.uber.getPrice(); return \"$\" + price * 0.9; //对price进行处理 },}/*decorate() 方法调用装饰者方法 sale.=sale.decorate(\"fedtax\");fedtax字符串对应 Sale.decorators中的对象属性。新装饰对象 newobj 将继承目前我们所拥有的对象，这就是ixiangthis为了完成继承部分代码，此时需要一个临时构造函数，先设置 newobj 的 uber 属性，以便于自对象可以访问到父对象。之后从装饰者中将所有的额外属性复制到新装饰的对象 newobj 中，最后返回 newobj。*/Sale.prototype.decorate = function(decorate) { var F = function() {}; var overrides = this.constructor.decorators[decorate]; //获取装饰者对象 F.prototype = this; var newobj = new F(); newobj.uber = F.prototype; for (var key in overrides) { if (overrides.hasOwnProperty) { //判断对象是不是自身的 newobj[key] = overrides[key]; } } return newobj;};var sale = new Sale(100);sale = sale.decorate(\"fedtax\"); //联邦税sale = sale.decorate(\"quebec\"); //魁北克省税sale = sale.decorate(\"money\"); //转为美元格式console.log(sale.getPrice()); //$50.4 方法二此方法使用列表实现，而且相对来说比较好理解一点。本质就是把装饰者名称保存到一个列表中并且一次调用此列表中的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Sale(price) { this.price = price; this.decorateList = [];}Sale.decorators = {};Sale.decorators.fedtax = { getPrice: function(price) { var price = this.uber.getPrice(); return price * 0.8; //对price进行处理 },}Sale.decorators.quebec = { getPrice: function(price) { var price = this.uber.getPrice(); return price * 0.7; //对price进行处理 },}Sale.decorators.money = { getPrice: function(price) { var price = this.uber.getPrice(); return \"$\" + price * 0.9; //对price进行处理 },}Sale.prototype.decorate = function(decorator) { this.decorateList.push(decorator);};Sale.prototype.getPrice = function() { var price = this.price; this.decorateList.forEach(function(name) { price = Sale.decorators[name].getPrice(price); }); return price;};var sale = new Sale(100);sale = sale.decorate(\"fedtax\"); //联邦税sale = sale.decorate(\"quebec\"); //魁北克省税sale = sale.decorate(\"money\"); //转为美元格式console.log(sale.getPrice()); //$50.4 策略模式策略模式支持在运行时候选择算法。例如用在表单验证问题上，可以创建一个具有 validate() 方法的验证器对象，无论表单具体类型是什么，该方法都会被调用，并且返回结果或者错误信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798var validator = { // 所有可以的验证规则处理类存放的地方，后面会单独定义 types: {}, // 验证类型所对应的错误消息 messages: [], // 当然需要使用的验证类型 config: {}, // 暴露的公开验证方法 // 传入的参数是 key =&gt; value对 validate: function (data) { var i, msg, type, checker, result_ok; // 清空所有的错误信息 this.messages = []; for (i in data) { if (data.hasOwnProperty(i)) { type = this.config[i]; // 根据key查询是否有存在的验证规则 checker = this.types[type]; // 获取验证规则的验证类 if (!type) { continue; // 如果验证规则不存在，则不处理 } if (!checker) { // 如果验证规则类不存在，抛出异常 throw { name: \"ValidationError\", message: \"No handler to validate type \" + type }; } result_ok = checker.validate(data[i]); // 使用查到到的单个验证类进行验证 if (!result_ok) { msg = \"Invalid value for *\" + i + \"*, \" + checker.instructions; this.messages.push(msg); } } } return this.hasErrors(); }, // helper hasErrors: function () { return this.messages.length !== 0; }};//然后剩下的工作，就是定义types里存放的各种验证类了// 验证给定的值是否不为空validator.types.isNonEmpty = { validate: function (value) { return value !== \"\"; }, instructions: \"传入的值不能为空\"};// 验证给定的值是否是数字validator.types.isNumber = { validate: function (value) { return !isNaN(value); }, instructions: \"传入的值只能是合法的数字，例如：1, 3.14 or 2010\"};// 验证给定的值是否只是字母或数字validator.types.isAlphaNum = { validate: function (value) { return !/[^a-z0-9]/i.test(value); }, instructions: \"传入的值只能保护字母和数字，不能包含特殊字符\"};//使用的时候，我们首先要定义需要验证的数据集合，然后还需要定义每种数据需要验证的规则类型，代码如下：var data = { first_name: \"Tom\", last_name: \"Xu\", age: \"unknown\", username: \"TomXu\"};validator.config = { first_name: 'isNonEmpty', age: 'isNumber', username: 'isAlphaNum'};//最后获取验证结果 validator.validate(data);if (validator.hasErrors()) { console.log(validator.messages.join(\"\\n\"));} 策略模式定义及例子实现参考与《javascript模式》及 汤姆大叔的博客 外观模式外观模式即让多个方法一起被调用 例如。 stopPropagation() 和 preventDefault() 兼容性一起调用。 1234567891011121314151617var myEvent = { stop: function(e) { if (typeof e.preventDefault() === \"function\") { e.preventDefault(); } if (typeof e.stopPropagation() === \"function\") { e.stopPropagation(); } //for IE if (typeof e.returnValue === \"boolean\") { e.returnValue = false; } if (typeof e.cancelBubble === \"boolean\") { e.cancelBubble = true; } }} 代理模式在代理模式中，一个对象充当另外一个对象的接口，和外观模式区别是：外观模式是合并调用多个方法。代理模式是介于对象的客户端和对象本身之间，并且对该对象的访问进行保护。 包裹例子现在有个包裹，卖家要把这个包裹寄给gary，则需要通过快递公司寄过来，此时快递公司就是一个 proxy 1234567891011121314151617181920var package = function(receiver) { this.receiver = receiver;}var seller = function(package) { this.package = package; this.send = function(gift) { return package.receiver + \"你的包裹:\" + gift; }}var express = function(package) { this.package = package; this.send = function(packageName) { return new seller(package).send(packageName); }}//调用var ems = new express(new package(\"gary\"));console.log(ems.send(\"键盘\")); //gary你的包裹:键盘 论坛权限管理例子本例子参考与 大熊君 权限列表 发帖 1 帖子审核 2 删帖 3 留言、回复 4 用户 代码 权限 注册用户 001 1 4 论坛管理员 002 2 3 4 系统管理员 003 1 2 3 4 游客 000 null 用户类123456789101112131415161718192021222324252627function User(name, code) { this.name = name; this.code = code;}User.prototype.getName = function() { return this.name;};User.prototype.getCode = function() { return this.code;};User.prototype.post = function() { //发帖功能};User.prototype.remove = function() { // 删帖功能};User.prototype.check = function() { //审核};User.prototype.comment = function() { //留言回复}; 论坛类1234567891011121314151617181920212223242526272829303132333435363738394041424344function Forum(user) { this.user=user;}Forum.prototype.getUser = function () { return this.user;};Forum.prototype.post = function () { var code=this.user.getCode(); if(code==\"001\"||code==\"003\"){ return this.user.post(); }else{ return false; }};Forum.prototype.remove = function () { var code=this.user.getCode(); if(code==\"002\"||code==\"003\"){ return this.user.remove(); }else{ return false; }};Forum.prototype.check = function () { var code=this.user.getCode(); if(code==\"002\"||code==\"003\"){ return this.user.check(); }else{ return false; }};Forum.prototype.comment = function () { var code=this.user.getCode(); if(code==\"001\"||code==\"002\"||code==\"003\"){ return this.user.comment(); }else{ return false; }}; 运行1new Forum(new User(\"administartor\",\"003\")); 中介者模式中介者模式可以让多个对象之间松耦合，并降低维护成本 例如：游戏程序，两名玩家分别给与半分钟时间来竞争决出胜负（谁按键的次数多胜出，这里玩家1按1，玩家2按0） 计分板（scoreboard) 中介者 （mediator) 中介者知道所有其他对象的信息。他与输入设备（此时是键盘）进行通信并处理键盘上的按键时间，之后还将消息通知玩家。玩家玩游戏同时（每一分都更新自己分数）还要通知中介者他所做的事情。中介者将更新后的分数传达给计分板。 除了中介者莫有对象知道其他对象。 图示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Player(name) { this.points = 0; this.name = name;}Player.prototype.play = function() { this.points += 1; mediator.played();};var scoreboard = { element: \"这里是获取的element用于展示分数\", update: function(score) { //更新分数 var msg; for (var key in score) { if (score.hasOwnProperty(key)) { msg += score[key]; } } this.element.innerText = msg; },}var mediator = { players: {}, //玩家对象 setup: function() { var players = this.players; players.home = new Player(\"home\"); players.guest = new Player('guest'); }, played: function() { var players = this.players; var score = { home: players.home.points, guest: players.guest.points } }, keypress: function(e) { e = e || window.event; if (e.which === 49) { //or keycode 对应按键 1 mediator.players.home.play(); return; } if (e.which === 48) { // 对应按键 0 mediator.player.guest.play(); return; } },}//运行mediator.setup();window.onkeypress = mediator.keypress;setTimeout(function() { //设置30秒游戏时间 window.onkeypress = null; alert(\"game end\");}, 30000); 观察者模式观察者模式在 javascript 中使用非常广泛。所有的浏览器时间就是该模式的实现，node.js中的events也是此模式实现。此模式另一个名称是 订阅/发布模式 。设计这种模式原因是促进形成松散耦合，在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改编后获得通知。订阅者因此也成为观察者，而被观察的对象成为发布者或者主题。当发生了一个重要事件时候发布者会通知（调用）所有订阅者并且可能经常已事件对象的形式传递消息。 例子我之前有篇文章即是观察者模式例子 nodejs的EventEmitter 小结1.单体模式针对一个类仅创建一个对象。 2.工厂模式根据字符串制定类型在运行时创建对象的方法。 3.迭代器模式提供一个API来遍历或者操作复杂的自定义数据结构。 4.装饰者模式通过从预定义装饰者对象中添加功能，从而在运行时侯调整对象 5.策略模式在悬在最佳策略以处理特定任务的时候仍然保持相同的接口。 6.外观模式通过把常用方法包装到一个新方法中，从来提供一个更为便利的API。 7.代理模式通过包装一个对象从而控制对它的访问，其中主要方法是将方位聚集为租或者仅当真正必要时侯才执行访问，从未避免高昂的操作开销。 8.终结者模式通过是你的对象之间相互不直接“通话”，而是通过一个中介者对子昂进行通信，从而形成松散耦合。 9.观察者模式通过创建“可观察”的对象，当发生一个感兴趣的事件时可将改时间通告给所有观察者从而形成松散耦合。","link":"/2017/01/14/设计模式/"},{"title":"数据结构JavaScript描述——列表（一）","text":"列表定义列表是一组有序的数据。每个列表中的数据称为 元素 。在JavaScript中，列表中的元素可以使任何数据类型，同时没有显示能保存多少元素 列表抽象数据类型定义属性和方法 listSize 列表的元素个数 pos 列表的当前元素 length() 返回列表元素个数 clear() 清空列表所有元素 toString() 返回列表字符串形式 getElement()返回当前位置元素 insert() 在现有元素后插入新元素 append() 在列表末尾添加新元素 remove()从列表中删除元素 front()将列表的当前位置移动到第一个元素 end() 将列表当前位置移动到最后一个元素 prev()将当前位置后移一位 next()将当前元素前移一位 currPos()返回列表的当前位置 moveTo()将当前位置移动到指定位置 实现列表类 123456789101112131415161718192021function List(){this.listSize=0;this.pos=0;this.dataStore=[];//初始化一个空数组来保存列表元素this.clear=clear;this.find=find;this.toString=toString;this.insert=insert;this.append=append;this.remo=remove;this.front=front;this.end=end;this.prev=prev;this.next=next;this.length=length;this.currPos=currPos;this.moveTo=moveTo;this.getElement=getElement;this.length=length;this.contains=contains;} append 给列表添加元素123function append(element){this.dataStore[this.listSize++]=element;} find在列表查找某一元素1234567891011121314151617function find(element){for(var i=0;i&lt;this.dataStore.length;i++){if(this.dataStore[i]==element{ return i; }}return -1;}#### remove从列表删除元素function remove(element){var foundAt=this.find(element);if(foundAt-1{ this.dataStore.splice(foundAt,1) --this.listsize; return false; }}","link":"/2016/05/12/数据结构JavaScript描述/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"作品","slug":"作品","link":"/tags/作品/"},{"name":"音频","slug":"音频","link":"/tags/音频/"},{"name":"angularjs","slug":"angularjs","link":"/tags/angularjs/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"template","slug":"template","link":"/tags/template/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"ES7","slug":"ES7","link":"/tags/ES7/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"配置","slug":"配置","link":"/tags/配置/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"教程","slug":"教程","link":"/tags/教程/"},{"name":"杂","slug":"杂","link":"/tags/杂/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"compiler","slug":"compiler","link":"/tags/compiler/"},{"name":"lib","slug":"lib","link":"/tags/lib/"}],"categories":[{"name":"css","slug":"css","link":"/categories/css/"},{"name":"杂","slug":"杂","link":"/categories/杂/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"作品","slug":"作品","link":"/categories/作品/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"},{"name":"翻译","slug":"翻译","link":"/categories/翻译/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"}]}